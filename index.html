<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Stickman Run</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: #0f172a;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        color: #fff
      }

      #gameContainer {
        position: relative;
        max-width: 800px;
        width: 100%;
        height: 500px
      }

      #gameCanvas {
        width: 100%;
        height: 100%;
        border: 2px solid rgba(34, 211, 238, 0.3);
        border-radius: 16px;
        display: block;
        box-shadow: 0 0 50px rgba(34, 211, 238, 0.2)
      }

      .hud {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        gap: 24px;
        z-index: 10
      }

      /* Centered top bar, positioned below the HUD to avoid overlap */
      #bestDiffBar {
        position: absolute;
        top: 56px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 12;
        background: rgba(2, 6, 23, 0.7);
        padding: 6px 12px;
        border-radius: 12px;
        border: 1px solid rgba(34, 211, 238, 0.12);
        font-weight: 700;
        color: #cbd5e1;
        pointer-events: none
      }

      @media(max-width:600px) {

        /* on small screens move the bar further down so it doesn't collide with wrapped HUD */
        #bestDiffBar {
          top: 88px;
          padding: 8px 14px;
          font-size: 14px
        }
      }

      /* top-right HUD buttons (Upgrades / Settings) */
      #hudTopRight {
        position: absolute;
        top: 16px;
        right: 16px;
        z-index: 13;
        display: flex;
        gap: 8px
      }

      .stat {
        background: rgba(30, 41, 59, 0.9);
        padding: 8px 16px;
        border-radius: 20px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: bold;
        font-size: 18px
      }

      #healthStat {
        flex-direction: row;
        align-items: center
      }

      #healthBar {
        width: 100px;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(239, 68, 68, 0.8);
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0
      }

      #healthBarFill {
        height: 100%;
        background: linear-gradient(to right, #ef4444, #f87171);
        width: 100%;
        transition: width 0.15s ease;
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3), 0 0 8px rgba(239, 68, 68, 0.6)
      }

      #mainMenu {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        border-radius: 16px;
        z-index: 20;
        padding: 40px;
        gap: 20px;
        flex-wrap: wrap
      }

      .hidden {
        display: none !important
      }

      /* common overlay base to center modal-like screens */
      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        padding: 20px
      }

      #charPreviewSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        flex: 0 0 260px
      }

      #charPreviewCanvas {
        border: 3px solid rgba(52, 211, 153, 0.5);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.3)
      }

      .changeCharBtn {
        background: linear-gradient(to right, #34d399, #10b981);
        color: #fff;
        border: none;
        padding: 12px 24px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 8px 20px rgba(52, 211, 153, 0.3);
        transition: all 0.2s
      }

      .changeCharBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 30px rgba(52, 211, 153, 0.5)
      }

      #mainMenuCenter {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 32px;
        flex: 1;
        min-width: 260px
      }

      #highScoreDisplay2 {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center
      }

      #highScoreLabel {
        font-size: 18px;
        color: #94a3b8;
        margin-bottom: -16px
      }

      .startGameBtn {
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        color: #fff;
        border: none;
        padding: 20px 60px;
        border-radius: 30px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3);
        transition: all 0.2s
      }

      .startGameBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(34, 211, 238, 0.5)
      }

      /* Upgrades UI */
      .upgradeOverlay {
        position: absolute;
        inset: 0;
        background: rgba(2, 6, 23, 0.92);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 21;
        padding: 24px;
        border-radius: 12px
      }

      .upgradeGrid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 18px;
        width: 80%;
        max-width: 720px
      }

      .upgradeItem {
        background: rgba(30, 41, 59, 0.9);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(34, 211, 238, 0.08);
        text-align: center
      }

      .upgradeItem h3 {
        margin: 6px 0 8px 0
      }

      .upgradeItem p {
        margin: 6px 0;
        color: #94a3b8
      }

      .upgradeBtn {
        background: linear-gradient(to right, #34d399, #10b981);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold
      }

      .upgradeBtn[disabled] {
        opacity: 0.45;
        cursor: not-allowed
      }

      .upClose {
        position: absolute;
        top: 18px;
        right: 18px;
        background: linear-gradient(to right, #ef4444, #dc2626);
        border: none;
        color: #fff;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer
      }

      #settingsTopRight {
        position: absolute;
        top: 40px;
        right: 40px
      }

      .settingsBtn {
        background: linear-gradient(to right, #64748b, #475569);
        color: #fff;
        border: none;
        padding: 12px 24px;
        border-radius: 20px;
        font-size: 16px;
        cursor: pointer;
        box-shadow: 0 8px 20px rgba(100, 116, 139, 0.3);
        transition: all 0.2s
      }

      .settingsBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 30px rgba(100, 116, 139, 0.5)
      }

      .settingsGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
        text-align: left
      }

      .settingItem {
        background: rgba(30, 41, 59, 0.6);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(52, 211, 153, 0.3)
      }

      .settingItem label {
        display: block;
        margin-bottom: 8px;
        color: #94a3b8;
        font-size: 14px
      }

      .settingItem input {
        width: 100%;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(52, 211, 153, 0.5);
        border-radius: 6px;
        color: #fff
      }

      h1 {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 16px
      }

      h2 {
        font-size: 36px;
        color: #ef4444;
        margin-bottom: 16px
      }

      .instructions {
        color: #94a3b8;
        text-align: center;
        margin-bottom: 32px;
        line-height: 1.6;
        padding: 0 16px
      }

      .classSelectOverlay {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 16px;
        z-index: 20
      }

      .menuButton {
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        color: #fff;
        border: none;
        padding: 16px 32px;
        border-radius: 30px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3);
        margin: 12px;
        min-width: 200px;
        transition: all 0.2s
      }

      .menuButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(34, 211, 238, 0.5)
      }

      .controls {
        display: none;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
        justify-content: center
      }

      @media(max-width:768px) {
        .controls {
          display: flex
        }

        h1 {
          font-size: 32px
        }
      }

      @media(max-width:900px) {
        #mainMenu {
          flex-direction: column;
          padding: 20px
        }

        #charPreviewSection,
        #mainMenuCenter {
          width: 100%;
          text-align: center
        }

        .upgradeGrid {
          grid-template-columns: repeat(1, 1fr);
          width: 95%
        }

        #hudTopRight {
          top: 12px;
          right: 12px
        }
      }

      .control-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(30, 41, 59, 0.8);
        border: 2px solid rgba(34, 211, 238, 0.5);
        color: #22d3ee;
        font-size: 20px;
        padding: 0
      }

      .jump {
        width: 64px;
        border-color: rgba(251, 191, 36, 0.5);
        color: #fbbf24;
        font-size: 14px
      }

      .attack {
        width: 64px;
        border-color: rgba(59, 130, 246, 0.5);
        color: #3b82f6;
        font-size: 24px
      }

      .heart {
        font-size: 20px
      }

      .empty {
        opacity: 0.3
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div class="hud">
        <div class="stat">
          <span>üí∞</span>
          <span id="coins">0</span>
        </div>
        <div class="stat">
          <span>ü™ô</span>
          <span id="score">0</span>
        </div>
        <div class="stat">
          <span>üèÜ</span>
          <span id="high">0</span>
        </div>
        <div class="stat" id="healthStat">
          <span>‚ù§Ô∏è</span>
          <div id="healthBar">
            <div id="healthBarFill"></div>
          </div>
        </div>
      </div>
      <div id="bestDiffBar">Distance to best: 0</div>
      <div id="hudTopRight">
        <button class="settingsBtn" onclick="goToUpgrades()">üõ† UPGRADES</button>
      </div>
      <canvas id="gameCanvas" width="800" height="500"></canvas>
      <canvas id="previewCanvas" width="800" height="500" style="display:none"></canvas>
      <div id="mainMenu" class="overlay classSelectOverlay">
        <div id="charPreviewSection">
          <canvas id="charPreviewCanvas" width="250" height="280" style="display:block"></canvas>
          <button class="changeCharBtn" onclick="goToClassSelect()">‚öô CHANGE CHARACTER</button>
        </div>
        <div id="mainMenuCenter">
          <div>
            <p id="highScoreLabel">üèÜ HIGH SCORE</p>
            <div id="highScoreDisplay2">0</div>
          </div>
          <button class="startGameBtn" onclick="startFromMainMenu()">‚ñ∂ START GAME</button>
          <button class="menuButton" onclick="goToUpgrades()">üõ† UPGRADES</button>
        </div>
        <div id="settingsTopRight">
          <button class="settingsBtn" onclick="goToSettings()">‚öô SETTINGS</button>
        </div>
      </div>
      <div id="classSelect" class="overlay classSelectOverlay hidden">
        <h1>SELECT YOUR CLASS</h1>
        <p class="instructions">Choose a class to see its abilities</p>
        <div id="previewContainer" style="width:100%;height:300px;margin:20px 0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.2);border-radius:12px;position:relative">
          <canvas id="classPreview" width="300" height="250" style="display:block"></canvas>
        </div>
        <div style="display:flex;gap:12px;margin-bottom:18px;flex-wrap:wrap;justify-content:center">
          <button id="class0" onclick="selectClass(0)" style="min-width:140px">1 ‚Ä¢ Runner <br>
            <small>Triple Jump</small>
          </button>
          <button id="class1" onclick="selectClass(1)" style="min-width:140px">2 ‚Ä¢ Archer <br>
            <small>Ranged Attack</small>
          </button>
          <button id="class2" onclick="selectClass(2)" style="min-width:140px">3 ‚Ä¢ Tank <br>
            <small>More Health</small>
          </button>
        </div>
        <button class="menuButton" onclick="startGame()">‚ñ∂ START GAME</button>
        <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569)">‚Üê BACK</button>
      </div>
      <div id="settings" class="overlay classSelectOverlay hidden">
        <div style="max-width:760px;width:100%;background:rgba(2,6,23,0.92);padding:20px;border-radius:12px">
          <h1>SETTINGS</h1>
          <div class="settingsGrid">
            <div class="settingItem">
              <label>Master Volume</label>
              <input type="range" id="volumeSlider" min="0" max="100" value="100" onchange="setSoundVolume(this.value)">
            </div>
            <div class="settingItem">
              <label>High Score</label>
              <input type="text" id="highScoreDisplay" readonly>
            </div>
            <div class="settingItem">
              <label>Jump Key</label>
              <input type="text" id="jumpKeyDisplay" value="SPACE / W / ‚Üë" readonly>
            </div>
            <div class="settingItem">
              <label>Debug Hunter AI</label>
              <div style="display:flex;align-items:center;gap:8px">
                <input type="checkbox" id="debugHuntersCheckbox" onchange="toggleHunterDebug(this.checked)">
                <small style="color:#94a3b8">Draw hunter path and targets</small>
              </div>
            </div>
            <div class="settingItem">
              <label>Attack Key</label>
              <input type="text" id="attackKeyDisplay" value="SHIFT / K" readonly>
            </div>
          </div>
          <div style="margin-top:24px;text-align:center;color:#94a3b8">
            <p style="margin:8px 0">Move: A/D or ‚Üê ‚Üí</p>
            <p style="margin:8px 0">All controls are fixed</p>
          </div>
          <div style="display:flex;gap:12px;justify-content:center;margin-top:16px">
            <button class="menuButton" onclick="clearHighScore()" style="background:linear-gradient(to right,#ef4444,#dc2626);">üóë CLEAR HIGH SCORE</button>
            <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569)">‚Üê BACK</button>
          </div>
        </div>
      </div>
      <!-- Upgrades Overlay -->
      <div id="upgrades" class="upgradeOverlay hidden">
        <button class="upClose" onclick="closeUpgrades()">‚úï</button>
        <h1 style="margin-bottom:6px">UPGRADES</h1>
        <p class="instructions">Spend coins to buy permanent upgrades. Costs scale per level.</p>
        <div class="upgradeGrid">
          <div class="upgradeItem">
            <h3>Damage</h3>
            <p id="upgDamageDesc">Increase weapon damage.</p>
            <p>Level: <span id="upgDamageLevel">0</span>
            </p>
            <p>Cost: <strong id="upgDamageCost">0</strong>
            </p>
            <button id="buyDamage" class="upgradeBtn" onclick="buyUpgrade('damage')">BUY</button>
          </div>
          <div class="upgradeItem">
            <h3>Speed</h3>
            <p id="upgSpeedDesc">Increase run speed (+8% per level).</p>
            <p>Level: <span id="upgSpeedLevel">0</span>
            </p>
            <p>Cost: <strong id="upgSpeedCost">0</strong>
            </p>
            <button id="buySpeed" class="upgradeBtn" onclick="buyUpgrade('speed')">BUY</button>
          </div>
          <div class="upgradeItem">
            <h3>Health</h3>
            <p id="upgHealthDesc">Increase max HP by +1 per level.</p>
            <p>Level: <span id="upgHealthLevel">0</span>
            </p>
            <p>Cost: <strong id="upgHealthCost">0</strong>
            </p>
            <button id="buyHealth" class="upgradeBtn" onclick="buyUpgrade('health')">BUY</button>
          </div>
        </div>
      </div>
      <div id="over" class="overlay classSelectOverlay hidden">
        <h2>GAME OVER</h2>
        <p style="font-size:24px;margin-bottom:32px">ü™ô Score: <span id="final">0</span>
          <br>üèÜ Best: <span id="best">0</span>
        </p>
        <p class="instructions" style="margin-bottom:12px">Choose a different class to try again</p>
        <div style="display:flex;gap:12px;margin-bottom:18px;flex-wrap:wrap;justify-content:center">
          <button id="classEnd0" onclick="selectClassAndRestart(0)" style="min-width:120px">Runner <br>
            <small>Triple Jump</small>
          </button>
          <button id="classEnd1" onclick="selectClassAndRestart(1)" style="min-width:120px">Archer <br>
            <small>Ranged Attack</small>
          </button>
          <button id="classEnd2" onclick="selectClassAndRestart(2)" style="min-width:120px">Tank <br>
            <small>More Health</small>
          </button>
        </div>
        <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569);margin-top:12px">‚Üê MAIN MENU</button>
      </div>
    </div>
    <div class="controls">
      <button class="control-btn" onmousedown="key('left',1)" onmouseup="key('left',0)" ontouchstart="key('left',1)" ontouchend="key('left',0)">‚Üê</button>
      <button class="control-btn jump" onmousedown="key('up',1)" onmouseup="key('up',0)" ontouchstart="key('up',1)" ontouchend="key('up',0)">JUMP</button>
      <button class="control-btn attack" onmousedown="key('swing',1)" onmouseup="key('swing',0)" ontouchstart="key('swing',1)" ontouchend="key('swing',0)">‚öîÔ∏è</button>
      <button class="control-btn" onmousedown="key('right',1)" onmouseup="key('right',0)" ontouchstart="key('right',1)" ontouchend="key('right',0)">‚Üí</button>
    </div>
    <p style="color:#64748b;font-size:14px;margin-top:16px">‚Üê ‚Üí or A/D to move ‚Ä¢ ‚Üë or W or SPACE to jump ‚Ä¢ SHIFT to attack</p>
    <script src="ai_hunter.js"></script>
    <script>
      // core setup
      var c = document.getElementById('gameCanvas'),
        ctx = c.getContext('2d'),
        W = 800,
        H = 500;
      // Cookie management
      function getCookie(name) {
        var nameEQ = name + "=";
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
          var cookie = cookies[i].trim();
          if (cookie.indexOf(nameEQ) === 0) return parseInt(cookie.substring(nameEQ.length));
        }
        return 0;
      }

      function setCookie(name, value, days) {
        days = days || 365;
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toUTCString();
        document.cookie = name + "=" + value + expires + "; path=/";
      }
      // Audio context for sound effects
      var audioCtx = null,
        soundVolume = getCookie('soundVolume') || 100;

      function getAudioContext() {
        if (!audioCtx) {
          audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      }

      function setSoundVolume(val) {
        soundVolume = val;
        setCookie('soundVolume', val);
        document.getElementById('volumeSlider').value = val;
      }
      // Sound effect functions
      function playSound(freq, duration, type) {
        try {
          var ctx = getAudioContext();
          if (ctx.state === 'suspended') {
            ctx.resume();
          }
          var osc = ctx.createOscillator(),
            env = ctx.createGain();
          osc.type = type || 'sine';
          osc.frequency.value = freq;
          var volumeGain = soundVolume / 100;
          env.gain.setValueAtTime(0.3 * volumeGain, ctx.currentTime);
          env.gain.exponentialRampToValueAtTime(0.01 * volumeGain, ctx.currentTime + duration);
          osc.connect(env);
          env.connect(ctx.destination);
          osc.start(ctx.currentTime);
          osc.stop(ctx.currentTime + duration);
        } catch (e) {}
      }

      function jumpSound() {
        playSound(400, 0.1, 'sine');
      }

      function coinSound() {
        playSound(800, 0.15, 'sine');
        playSound(1000, 0.1, 'sine');
      }

      function attackSound() {
        playSound(200, 0.08, 'square');
      }

      function damageSound() {
        playSound(150, 0.2, 'sine');
      }

      function gameOverSound() {
        playSound(200, 0.15, 'sine');
        playSound(150, 0.15, 'sine');
      }

      function shootSound() {
        playSound(600, 0.05, 'square');
      }
      // player classes
      var classes = [{
        id: 'Runner',
        desc: 'Triple jump',
        maxJumps: 3,
        hp: 3,
        ranged: false,
        color: '#60a5fa'
      }, {
        id: 'Archer',
        desc: 'Ranged attack',
        maxJumps: 2,
        hp: 2,
        ranged: true,
        color: '#34d399'
      }, {
        id: 'Tank',
        desc: 'More health',
        maxJumps: 2,
        hp: 5,
        ranged: false,
        color: '#f87171'
      }];
      var selClass = 0;
      var g = {
          p: null,
          plat: [],
          coinItems: [],
          obs: [],
          en: [],
          projectiles: [],
          sc: 0,
          dist: 0,
          coins: 0,
          cam: 0,
          pgen: 0,
          over: 0,
          start: 0,
          k: {
            left: 0,
            right: 0,
            up: 0,
            swing: 0,
            attack: 0
          },
          hi: getCookie('highScore') || 0,
          bestDist: Number(getCookie('bestDist') || 0),
          targetLock: null,
          hunters: [],
          spawnMul: 1,
          showHunterDebug: (getCookie('showHunterDebug') ? true : false)
        },
        anim = null;

      function rnd(a, b) {
        return Math.random() * (b - a) + a
      }

      function genPlat(x, prevPlat) {
        var gap = rnd(80, 180),
          w = Math.random() > .7 ? rnd(180, 280) : rnd(80, 180),
          y = rnd(200, 400);
        // only add spikes if previous platform didn't have them (ensure at least 1 normal platform between spikes)
        var hasSpikes = prevPlat && !prevPlat.spikes ? Math.random() > 0.75 : false;
        return {
          x: x + gap,
          y: y,
          w: w,
          h: 15,
          spikes: hasSpikes
        }
      }

      function genCoin(p) {
        if (Math.random() > .6) return {
          x: p.x + p.w / 2,
          y: p.y - 40,
          r: 12,
          c: 0
        };
        return null
      }

      function genObs(p, i) {
        if (i < 10 || Math.random() > .7 || p.w < 100) return null;
        return {
          x: p.x + rnd(15, p.w - 45),
          y: p.y - 25,
          w: 20,
          h: 25
        }
      }

      function dropPowerup(x, y, dropRate) {
        // dropRate: 0.4 = 40%, 0.25 = 25%, etc. Default is 40%
        dropRate = dropRate || 0.4;
        if (Math.random() > (1 - dropRate)) return;
        var types = ['health', 'speed', 'shield'];
        var type = types[Math.floor(Math.random() * types.length)];
        var powerup = {
          x: x,
          y: y,
          w: 15,
          h: 15,
          type: type,
          vx: (Math.random() - 0.5) * 3,
          vy: -5,
          life: 300 // 5 seconds at 60fps
        };
        g.powerups.push(powerup);
      }

      function genEn(p, i) {
        if (i < 5 || p.w < 150 || Math.random() > .5) return null;
        var rand = Math.random();
        var type = 'normal';
        if (rand > 0.70) type = 'hunter';
        else if (rand > 0.55) type = 'archer'; // 15% chance for archer
        var en = {
          x: p.x + p.w / 2,
          y: p.y - 40,
          w: 25,
          h: 40,
          vx: (Math.random() > .5 ? 1 : -1) * 2,
          pl: p.x,
          pr: p.x + p.w,
          dead: 0,
          hp: 2,
          type: type,
          escaped: 0,
          vy: 0,
          gnd: 0,
          jl: 0,
          // AI state
          _path: null,
          _pathTimer: 0,
          _thinkCooldown: 0,
          _jumpingTo: null,
          _doubleJumpUsed: false,
          // archer state
          _shootCooldown: 0
        };
        if (type === 'hunter') {
          en.hp = 3;
          en.speed = 3;
          en.jl = 2;
        } else if (type === 'archer') {
          en.hp = 2;
          en.speed = 1.5;
          en._shootCooldown = 0;
        }
        return en
      }

      function selectClass(i) {
        selClass = i;
        updateClassUI();
        drawClassPreview();
        drawMainMenuCharPreview()
      }

      function updateClassUI() { // highlight selected
        for (var i = 0; i < 3; i++) {
          var btn = document.getElementById('class' + i);
          if (!btn) continue;
          btn.style.outline = (i === selClass) ? '3px solid rgba(255,255,255,0.12)' : '';
          var bEnd = document.getElementById('classEnd' + i);
          if (bEnd) bEnd.style.outline = (i === selClass) ? '3px solid rgba(255,255,255,0.12)' : ''
        }
      }

      function goToMainMenu() {
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
        drawMainMenuCharPreview()
      }

      function goToClassSelect() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('classSelect').classList.remove('hidden');
        drawClassPreview()
      }

      function goToSettings() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.remove('hidden');
        document.getElementById('highScoreDisplay').value = g.hi;
        document.getElementById('volumeSlider').value = soundVolume;
        loadSettings();
      }

      function drawMainMenuCharPreview() {
        var canvas = document.getElementById('charPreviewCanvas');
        if (!canvas) return;
        var pctx = canvas.getContext('2d');
        var cls = classes[selClass];
        pctx.fillStyle = '#071022';
        pctx.fillRect(0, 0, canvas.width, canvas.height);
        var cx = canvas.width / 2,
          cy = canvas.height / 2 - 20;
        pctx.save();
        pctx.strokeStyle = cls.color;
        pctx.lineWidth = 4;
        pctx.lineCap = 'round';
        pctx.beginPath();
        pctx.arc(cx, cy - 25, 15, 0, Math.PI * 2);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy);
        pctx.lineTo(cx, cy + 35);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 10);
        pctx.lineTo(cx - 20, cy + 25);
        pctx.moveTo(cx, cy + 10);
        pctx.lineTo(cx + 20, cy + 25);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 35);
        pctx.lineTo(cx - 15, cy + 60);
        pctx.moveTo(cx, cy + 35);
        pctx.lineTo(cx + 15, cy + 60);
        pctx.stroke();
        pctx.restore();
        pctx.fillStyle = '#fff';
        pctx.font = 'bold 20px Arial';
        pctx.textAlign = 'center';
        pctx.fillText(cls.id, cx, cy + 100);
        pctx.font = '14px Arial';
        pctx.fillStyle = cls.color;
        pctx.fillText('‚ù§Ô∏è HP: ' + cls.hp, cx, cy + 125);
        pctx.fillText('‚¨ÜÔ∏è Jumps: ' + cls.maxJumps, cx, cy + 145);
      }

      function startFromMainMenu() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        init();
        anim = requestAnimationFrame(loop)
      }

      function drawClassPreview() {
        var pcanvas = document.getElementById('classPreview');
        if (!pcanvas) return;
        var pctx = pcanvas.getContext('2d');
        var cls = classes[selClass];
        pctx.fillStyle = '#071022';
        pctx.fillRect(0, 0, pcanvas.width, pcanvas.height);
        var cx = pcanvas.width / 2,
          cy = pcanvas.height / 2 - 20;
        // draw stick figure
        pctx.save();
        pctx.strokeStyle = cls.color;
        pctx.lineWidth = 3;
        pctx.lineCap = 'round';
        pctx.beginPath();
        pctx.arc(cx, cy - 20, 12, 0, Math.PI * 2);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy);
        pctx.lineTo(cx, cy + 25);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 8);
        pctx.lineTo(cx - 15, cy + 20);
        pctx.moveTo(cx, cy + 8);
        pctx.lineTo(cx + 15, cy + 20);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 25);
        pctx.lineTo(cx - 12, cy + 45);
        pctx.moveTo(cx, cy + 25);
        pctx.lineTo(cx + 12, cy + 45);
        pctx.stroke();
        pctx.restore();
        // class info
        pctx.fillStyle = '#fff';
        pctx.font = 'bold 18px Arial';
        pctx.textAlign = 'center';
        pctx.fillText(cls.id, cx, cy + 70);
        pctx.font = '14px Arial';
        pctx.fillStyle = cls.color;
        pctx.fillText('‚ù§Ô∏è HP: ' + cls.hp, cx, cy + 95);
        pctx.fillText('‚¨ÜÔ∏è Jumps: ' + cls.maxJumps, cx, cy + 115);
        if (cls.ranged) {
          pctx.fillText('‚á¢ Ranged Attack (K)', cx, cy + 135)
        }
      }

      function selectClassAndRestart(i) {
        selClass = i;
        updateClassUI();
        drawClassPreview();
        restart()
      }

      function init() {
        var cls = classes[selClass];
        // load upgrades (persisted)
        loadUpgrades();
        // load settings (persisted)
        loadSettings();
        var extraHp = g.upgrades ? (g.upgrades.health || 0) : 0;
        var maxHp = cls.hp + extraHp;
        g.p = {
          x: 150,
          y: 200,
          vy: 0,
          vx: 0,
          w: 30,
          h: 50,
          jump: 0,
          gnd: 0,
          f: 0,
          right: 1,
          swing: 0,
          sf: 0,
          jl: cls.maxJumps,
          hp: maxHp,
          inv: 0,
          attackCd: 0,
          attackCdMax: 0,
          canShoot: 1,
          charging: false,
          charge: 0,
          chargeMax: 40
        };
        g.plat = [{
          x: 50,
          y: 350,
          w: 200,
          h: 15
        }];
        g.coinItems = [];
        g.obs = [];
        g.en = [];
        g.projectiles = [];
        g.powerups = [];
        g.cam = 0;
        g.pgen = 1;
        g.hunters = [];
        g.spawnMul = 1;
        var last = g.plat[0];
        for (var i = 0; i < 10; i++) {
          var np = genPlat(last.x + last.w);
          g.plat.push(np);
          g.pgen++;
          var co = genCoin(np);
          if (co) g.coinItems.push(co);
          var ob = genObs(np, g.pgen);
          if (ob) g.obs.push(ob);
          var e = genEn(np, g.pgen);
          if (e) g.en.push(e);
          last = np
        }
        g.sc = 0;
        g.dist = 0;
        g.coins = 0;
        g.over = 0;
        g.start = 1;
        upSc();
        upHp();
        updateClassUI();
        updateBestDiff();
      }

      function drawStick(p, cam) {
        var x = p.x - cam,
          cx = x + 15,
          y = p.y,
          mv = Math.abs(p.vx) > .5;
        if (p.inv > 0 && Math.floor(p.inv / 5) % 2 == 0) return;
        ctx.save();
        var cls = classes[selClass];
        ctx.strokeStyle = p.inv > 0 ? '#fca5a5' : cls.color;
        ctx.shadowColor = cls.color;
        ctx.shadowBlur = 4;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // head with gradient
        var grad = ctx.createRadialGradient(cx, y + 10, 2, cx, y + 10, 10);
        grad.addColorStop(0, cls.color);
        grad.addColorStop(1, 'rgba(96,165,250,0.6)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, y + 10, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(cx, y + 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        // body
        ctx.beginPath();
        ctx.moveTo(cx, y + 20);
        ctx.lineTo(cx, y + 38);
        ctx.stroke();
        var as = mv ? p.f * .3 : 0,
          ls = Math.sin(as) * 8;
        // legs
        ctx.beginPath();
        ctx.moveTo(cx, y + 38);
        ctx.lineTo(cx + (p.gnd ? ls : -4), y + 50);
        ctx.moveTo(cx, y + 38);
        ctx.lineTo(cx + (p.gnd ? -ls : 4), y + 50);
        ctx.stroke();
        var sd = p.right ? 1 : -1;
        if (p.swing) {
          var sa = (p.sf / 15) * Math.PI - Math.PI / 4,
            aex = cx + Math.cos(sa) * 12 * sd,
            aey = y + 25 + Math.sin(sa) * 12;
          ctx.beginPath();
          ctx.moveTo(cx, y + 25);
          ctx.lineTo(aex, aey);
          ctx.stroke();
          var sl = 32,
            sex = aex + Math.cos(sa) * sl * sd,
            sey = aey + Math.sin(sa) * sl;
          ctx.shadowColor = '#fbbf24';
          ctx.shadowBlur = 6;
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.strokeStyle = '#ffe082';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else {
          // basic forearm
          ctx.beginPath();
          ctx.moveTo(cx, y + 25);
          ctx.lineTo(cx + 8 * sd, y + 30);
          ctx.stroke();
          var handx = cx + 8 * sd,
            handy = y + 30;
          if (cls.ranged) {
            // draw a simple bow in the hand
            ctx.save();
            ctx.strokeStyle = '#8b5a2b';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            if (sd > 0) {
              // bow limb: bulge AWAY from the player when facing right (convex outward)
              ctx.moveTo(handx - 2, handy - 12);
              ctx.quadraticCurveTo(handx + 18, handy, handx - 2, handy + 12);
            } else {
              // facing left: bow limb bulges AWAY from the player (convex outward)
              ctx.moveTo(handx + 2, handy - 12);
              ctx.quadraticCurveTo(handx - 18, handy, handx + 2, handy + 12);
            }
            ctx.stroke();
            // bow string with dynamic pull (use charge when holding)
            var pull = 0;
            if (p.charging && p.chargeMax) pull = p.charge / p.chargeMax; // 0..1 while holding
            var strOff = Math.round(pull * 12); // how far the string is offset
            ctx.strokeStyle = 'rgba(255,255,255,0.95)';
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            // align string endpoints to bow curve endpoints for correct placement
            if (sd > 0) {
              // string endpoints (top -> bottom)
              var bx1x = handx - 2,
                bx1y = handy - 12;
              var bx2x = handx - 2,
                bx2y = handy + 12;
              ctx.moveTo(bx1x, bx1y);
              if (strOff === 0) {
                // straight string when not pulled
                ctx.lineTo(bx2x, bx2y);
              } else {
                // when pulled, move the string control point TOWARD the player (left)
                ctx.quadraticCurveTo(handx - 18 - strOff, handy, bx2x, bx2y);
              }
            } else {
              var bx1x = handx + 2,
                bx1y = handy - 12;
              var bx2x = handx + 2,
                bx2y = handy + 12;
              ctx.moveTo(bx1x, bx1y);
              if (strOff === 0) {
                // straight string when not pulled
                ctx.lineTo(bx2x, bx2y);
              } else {
                // when pulled, move the string control point TOWARD the player (right)
                ctx.quadraticCurveTo(handx + 18 + strOff, handy, bx2x, bx2y);
              }
            }
            ctx.stroke();
            // draw nocked arrow while charging (gives visual feedback)
            if (p.charging) {
              ctx.strokeStyle = '#cbd5e1';
              ctx.lineWidth = 2;
              ctx.beginPath();
              // place the nocked arrow on the inner side (between string and player)
              // offset the arrow position by the string pull so it moves back with the string
              var pullShift = strOff; // reuse computed string offset (pixels)
              var ax = handx + (sd > 0 ? -8 - pullShift : 8 + pullShift);
              var ay = handy;
              var arrowLen = 20;
              if (sd > 0) {
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax + arrowLen, ay);
                ctx.moveTo(ax + arrowLen, ay);
                ctx.lineTo(ax + arrowLen - 4, ay - 3);
                ctx.moveTo(ax + arrowLen, ay);
                ctx.lineTo(ax + arrowLen - 4, ay + 3);
              } else {
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax - arrowLen, ay);
                ctx.moveTo(ax - arrowLen, ay);
                ctx.lineTo(ax - arrowLen + 4, ay - 3);
                ctx.moveTo(ax - arrowLen, ay);
                ctx.lineTo(ax - arrowLen + 4, ay + 3);
              }
              ctx.stroke();
            }
            ctx.restore();
          } else {
            var ha = Math.PI / 6 * sd,
              hx = cx + 8 * sd,
              hy = y + 30,
              bex = hx + Math.sin(ha) * 28,
              bey = hy + 22;
            ctx.shadowColor = 'rgba(96,165,250,0.8)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = cls.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(bex, bey);
            ctx.stroke();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(bex, bey);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        }
        // arms
        ctx.strokeStyle = p.inv > 0 ? '#fca5a5' : cls.color;
        ctx.lineWidth = 3;
        var asw = Math.sin(as) * 6;
        ctx.beginPath();
        ctx.moveTo(cx, y + 25);
        ctx.lineTo(cx + (mv ? asw : -8) * (p.right ? -1 : 1), y + 32);
        ctx.stroke();
        ctx.restore();
      }

      function drawPlat(p, cam) {
        var x = p.x - cam;
        var r = 8; // border radius
        // draw platform with rounded corners
        ctx.save();
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 2;
        var grad = ctx.createLinearGradient(x, p.y, x, p.y + p.h);
        grad.addColorStop(0, '#06b6d4');
        grad.addColorStop(1, '#0891b2');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(x + r, p.y);
        ctx.lineTo(x + p.w - r, p.y);
        ctx.quadraticCurveTo(x + p.w, p.y, x + p.w, p.y + r);
        ctx.lineTo(x + p.w, p.y + p.h - r);
        ctx.quadraticCurveTo(x + p.w, p.y + p.h, x + p.w - r, p.y + p.h);
        ctx.lineTo(x + r, p.y + p.h);
        ctx.quadraticCurveTo(x, p.y + p.h, x, p.y + p.h - r);
        ctx.lineTo(x, p.y + r);
        ctx.quadraticCurveTo(x, p.y, x + r, p.y);
        ctx.closePath();
        ctx.fill();
        // top highlight
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(x + 2, p.y + 1, p.w - 4, 2);
        // draw spikes if this is a trap platform (same color, hard to see)
        if (p.spikes) {
          ctx.fillStyle = '#0891b2';
          var spikeCount = Math.floor(p.w / 12);
          for (var i = 0; i < spikeCount; i++) {
            var sx = x + (p.w / spikeCount) * i + (p.w / spikeCount) / 2;
            ctx.beginPath();
            ctx.moveTo(sx - 3, p.y);
            ctx.lineTo(sx + 3, p.y);
            ctx.lineTo(sx, p.y - 4);
            ctx.closePath();
            ctx.fill();
          }
        }
        ctx.restore();
      }

      function drawCoin(co, t, cam) {
        if (co.c) return;
        var x = co.x - cam,
          pu = Math.sin(t * .005) * 2;
        ctx.save();
        ctx.translate(x, co.y);
        ctx.rotate(t * 0.003);
        // outer glow
        ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, co.r + 6, 0, Math.PI * 2);
        ctx.fill();
        // main coin with gradient
        var grad = ctx.createRadialGradient(0, -3, 0, 0, 0, co.r);
        grad.addColorStop(0, '#fcd34d');
        grad.addColorStop(0.7, '#fbbf24');
        grad.addColorStop(1, '#f59e0b');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, co.r + pu, 0, Math.PI * 2);
        ctx.fill();
        // shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(-3, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawObs(o, cam) {
        var x = o.x - cam;
        ctx.save();
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 2;
        ctx.fillStyle = '#dc2626';
        ctx.beginPath();
        ctx.moveTo(x, o.y + o.h);
        ctx.lineTo(x + o.w / 2, o.y - 2);
        ctx.lineTo(x + o.w, o.y + o.h);
        ctx.closePath();
        ctx.fill();
        // highlight on spike
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + o.w / 2 - 1, o.y);
        ctx.lineTo(x + o.w / 2 + 1, o.y);
        ctx.stroke();
        ctx.restore();
      }

      function drawEn(e, cam) {
        if (e.dead) return;
        var x = e.x - cam,
          cx = x + 12,
          y = e.y;
        ctx.save();
        var isHunter = e.type === 'hunter';
        var isArcher = e.type === 'archer';
        ctx.shadowColor = isHunter ? '#a855f7' : isArcher ? '#0ea5e9' : '#ef4444';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 1;
        // head with gradient
        var grad = ctx.createRadialGradient(cx, y + 8, 2, cx, y + 8, 8);
        if (isHunter) {
          grad.addColorStop(0, '#d946ef');
          grad.addColorStop(1, '#a855f7');
        } else if (isArcher) {
          grad.addColorStop(0, '#06b6d4');
          grad.addColorStop(1, '#0891b2');
        } else {
          grad.addColorStop(0, '#f87171');
          grad.addColorStop(1, '#dc2626');
        }
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, y + 8, 8, 0, Math.PI * 2);
        ctx.fill();
        // outline
        ctx.strokeStyle = isHunter ? '#7c3aed' : isArcher ? '#0369a1' : '#991b1b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, y + 8, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (isHunter) {
          // hunter has glowing eyes
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 1, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 1, 0, Math.PI * 2);
          ctx.fill();
          // hunter has sharper limbs
          ctx.strokeStyle = '#d946ef';
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 32);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 22);
          ctx.lineTo(cx - 10, y + 28);
          ctx.moveTo(cx, y + 22);
          ctx.lineTo(cx + 10, y + 28);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 32);
          ctx.lineTo(cx - 7, y + 42);
          ctx.moveTo(cx, y + 32);
          ctx.lineTo(cx + 7, y + 42);
          ctx.stroke();
        } else if (isArcher) {
          // archer has targeting reticle eyes
          ctx.fillStyle = '#06b6d4';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#0369a1';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2.5, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2.5, 0, Math.PI * 2);
          ctx.stroke();
          // archer body and bow
          ctx.strokeStyle = '#0ea5e9';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 30);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 20);
          ctx.lineTo(cx - 8, y + 26);
          ctx.moveTo(cx, y + 20);
          ctx.lineTo(cx + 8, y + 26);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx - 6, y + 40);
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx + 6, y + 40);
          ctx.stroke();
          // draw bow in hand
          ctx.strokeStyle = '#0891b2';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cx + 12, y + 20, 5, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          // regular enemy eyes
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 1, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 1, 0, Math.PI * 2);
          ctx.fill();
          // body and limbs
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 30);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 20);
          ctx.lineTo(cx - 8, y + 26);
          ctx.moveTo(cx, y + 20);
          ctx.lineTo(cx + 8, y + 26);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx - 6, y + 40);
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx + 6, y + 40);
          ctx.stroke();
        }
        // hp indicator
        if (e.hp > 0) {
          ctx.fillStyle = '#fef08a';
          ctx.font = 'bold 11px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(e.hp, cx, y - 8)
        }
        ctx.restore();
      }
      // Platform path utilities moved to ai_hunter.js for modularity
      // (findPlatformIndexAtX, platformGap, canJump, findPlatformPath, findHunterPath)
      // The functions are loaded from ai_hunter.js which is included before this script.
      // Fallback implementations if module fails to load
      if (typeof findPlatformIndexAtX === 'undefined') {
        window.findPlatformIndexAtX = function(x, w) {
          var cx = x + (w || 0) / 2;
          for (var i = 0; i < (window.g && g.plat ? g.plat.length : 0); i++) {
            var pl = g.plat[i];
            if (cx >= pl.x && cx <= pl.x + pl.w) return i;
          }
          return -1;
        };
      }
      if (typeof canJump === 'undefined') {
        window.canJump = function(from, to) {
          if (!from || !to) return false;
          var gap = (to.x > from.x) ? (to.x - (from.x + from.w)) : (from.x - (to.x + to.w));
          if (gap > 240) return false;
          if (to.y - from.y > 160) return false;
          return true;
        };
      }
      if (typeof findPlatformPath === 'undefined') {
        window.findPlatformPath = function(startIdx, targetIdx) {
          if (!window.g || !g.plat || startIdx === -1 || targetIdx === -1) return null;
          if (startIdx === targetIdx) return [startIdx];
          // Simple BFS if A* not available
          var visited = {}; visited[startIdx] = true;
          var queue = [[startIdx]]; 
          while (queue.length) {
            var path = queue.shift();
            var cur = path[path.length - 1];
            if (cur === targetIdx) return path;
            var curPl = g.plat[cur];
            for (var j = 0; j < g.plat.length; j++) {
              if (j === cur || visited[j]) continue;
              if (canJump(curPl, g.plat[j]) || canJump(g.plat[j], curPl)) {
                visited[j] = true;
                queue.push(path.concat([j]));
              }
            }
          }
          return null;
        };
      }

      function coll(r1, r2) {
        return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y
      }

      function getSwHit(p) {
        var sd = p.right ? 1 : -1,
          cx = p.x + 15;
        return {
          x: cx + (sd > 0 ? 10 : -40),
          y: p.y + 10,
          w: 40,
          h: 35
        }
      }

      function findClosestTarget(p, cam) {
        var closest = null,
          minDist = 300; // max targeting range
        for (var i = 0; i < g.en.length; i++) {
          var e = g.en[i];
          if (e.dead) continue;
          var ex = e.x - cam,
            ey = e.y;
          if (ex < 0 || ex > W) continue; // only target if within frame
          var dx = ex - (p.x - cam + 15),
            dy = ey - (p.y + 20);
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            closest = e;
          }
        }
        return closest;
      }

      function upSc() {
        document.getElementById('score').textContent = g.sc;
        g.coins = Math.floor(g.sc * 0.1);
        document.getElementById('coins').textContent = g.coins;
        document.getElementById('high').textContent = g.hi;
        document.getElementById('highScoreDisplay2').textContent = g.hi;
        updateUpgradeUI()
      }

      function upHp() {
        var maxHp = classes[selClass].hp + (g.upgrades ? (g.upgrades.health || 0) : 0);
        var percentage = Math.max(0, Math.min(100, (g.p.hp / maxHp) * 100));
        document.getElementById('healthBarFill').style.width = percentage + '%';
      }

      function updateBestDiff() {
        var el = document.getElementById('bestDiffBar');
        if (!el) return;
        var best = g.bestDist || 0;
        var diff = g.dist - best;
        var sign = diff > 0 ? '+' : '';
        el.textContent = 'Distance to best: ' + sign + diff;
        // color positive green, negative/red when behind, neutral gray
        if (diff > 0) el.style.background = 'rgba(4,120,87,0.9)', el.style.color = '#bbf7d0';
        else if (diff < 0) el.style.background = 'rgba(83,37,28,0.9)', el.style.color = '#fecaca';
        else el.style.background = 'rgba(2,6,23,0.7)', el.style.color = '#cbd5e1';
      }
      // Upgrades: load/save and UI
      function loadUpgrades() {
        g.upgrades = {
          damage: Number(getCookie('upg_damage') || 0),
          speed: Number(getCookie('upg_speed') || 0),
          health: Number(getCookie('upg_health') || 0)
        };
      }

      function saveUpgrade(key) {
        setCookie('upg_' + key, g.upgrades[key] || 0);
      }

      function getUpgradeCost(key) {
        var base = {
          damage: 200,
          speed: 150,
          health: 120
        } [key] || 100;
        var lvl = g.upgrades[key] || 0;
        return Math.max(50, Math.round(base * Math.pow(2, lvl)));
      }

      function updateUpgradeUI() {
        if (!g.upgrades) loadUpgrades();
        document.getElementById('upgDamageLevel').textContent = g.upgrades.damage;
        document.getElementById('upgSpeedLevel').textContent = g.upgrades.speed;
        document.getElementById('upgHealthLevel').textContent = g.upgrades.health;
        document.getElementById('upgDamageCost').textContent = getUpgradeCost('damage');
        document.getElementById('upgSpeedCost').textContent = getUpgradeCost('speed');
        document.getElementById('upgHealthCost').textContent = getUpgradeCost('health');
        // enable/disable buttons based on available currency
        var sd = g.coins >= getUpgradeCost('damage');
        var ss = g.coins >= getUpgradeCost('speed');
        var sh = g.coins >= getUpgradeCost('health');
        document.getElementById('buyDamage').disabled = !sd;
        document.getElementById('buySpeed').disabled = !ss;
        document.getElementById('buyHealth').disabled = !sh;
      }

      // Settings: debug toggles and persistence
      function loadSettings() {
        var raw = document.cookie.split(';').map(function(s){return s.trim();}).find(function(s){return s.indexOf('dbg_hunter=')===0});
        if (raw === undefined) g.showHunterDebug = true; else g.showHunterDebug = Number(raw.split('=')[1]) === 1;
        var el = document.getElementById('debugHuntersCheckbox'); if (el) el.checked = g.showHunterDebug;
      }
      function toggleHunterDebug(checked) {
        g.showHunterDebug = !!checked; setCookie('dbg_hunter', g.showHunterDebug ? 1 : 0);
      }

      // toggle debug drawing for hunters
      function toggleHunterDebug(checked) {
        g.debugHunterPaths = !!checked;
        setCookie('debugHunters', checked ? 1 : 0);
      }

      function goToUpgrades() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        document.getElementById('upgrades').classList.remove('hidden');
        updateUpgradeUI();
      }

      function closeUpgrades() {
        document.getElementById('upgrades').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
      }

      function buyUpgrade(key) {
        var cost = getUpgradeCost(key);
        if (g.coins < cost) return;
        g.coins -= cost; // spend coins
        g.upgrades[key] = (g.upgrades[key] || 0) + 1;
        saveUpgrade(key);
        updateUpgradeUI();
        // reapply upgrades to player if inited
        if (g.p) {
          if (key === 'health') {
            g.p.hp += 1;
            upHp();
          }
        }
      }

      function endGame() {
        g.over = 1;
        if (g.sc > g.hi) {
          g.hi = g.sc;
          setCookie('highScore', g.hi)
        }
        // persist best distance
        if (g.dist > (g.bestDist || 0)) {
          g.bestDist = g.dist;
          setCookie('bestDist', g.bestDist)
        }
        document.getElementById('final').textContent = g.sc;
        document.getElementById('best').textContent = g.hi;
        document.getElementById('over').classList.remove('hidden');
        if (anim) cancelAnimationFrame(anim);
        gameOverSound();
        updateBestDiff();
      }

      function loop(t) {
        if (g.over || !g.start) return;
        try {
          anim = requestAnimationFrame(loop);
          // enhanced background with gradient
          var bgGrad = ctx.createLinearGradient(0, 0, 0, H);
          bgGrad.addColorStop(0, '#0f172a');
          bgGrad.addColorStop(1, '#1e293b');
          ctx.fillStyle = bgGrad;
          ctx.fillRect(0, 0, W, H);
          var p = g.p;
          var cls = classes[selClass];
        var speedMul = 1 + ((g.upgrades && g.upgrades.speed) ? (0.08 * g.upgrades.speed) : 0);
        // apply speed boost if active
        if (p._speedBoost && p._speedBoost > 0) {
          p._speedBoost--;
          speedMul *= 1.4; // 40% faster
        }
        var baseSpeed = 6 * speedMul;
        if (g.k.left) {
          p.vx = -baseSpeed;
          p.right = 0
        } else if (g.k.right) {
          p.vx = baseSpeed;
          p.right = 1
        } else p.vx *= .8
        // jump handling uses class max jumps
        if (g.k.up && p.jl > 0) {
          p.vy = -14;
          p.jump = 1;
          p.gnd = 0;
          p.jl--;
          g.k.up = 0;
          jumpSound()
        }
        // ranged attack (Archer) with auto-targeting and hold-to-draw
        if (cls.ranged) {
          g.targetLock = findClosestTarget(p, g.cam);
          // start charging on attack press (if weapon is ready)
          if (g.k.attack && p.canShoot && !p.charging) {
            p.charging = true;
            p.charge = 0;
          }
          // accumulate charge while holding
          if (p.charging) {
            p.charge++;
            if (p.charge > p.chargeMax) p.charge = p.chargeMax;
          }
          // release: when attack key lifted and we were charging
          if (!g.k.attack && p.charging) {
            var power = p.charge / p.chargeMax; // 0..1
            var tgtX = g.targetLock ? g.targetLock.x - g.cam : p.x + (p.right ? p.w : -8);
            var tgtY = g.targetLock ? g.targetLock.y : p.y;
            var angle = Math.atan2(tgtY - (p.y + 20), tgtX - (p.x - g.cam + 15));
            var speed = 6 + power * 14; // range ~6 - 20
            var vx = Math.cos(angle) * speed,
              vy = Math.sin(angle) * speed;
            var pr = {
              x: p.x + (p.right ? p.w : -8),
              y: p.y + 20,
              vx: vx,
              vy: vy,
              w: 10,
              h: 4,
              life: 80,
              type: 'arrow',
              rot: angle,
              power: power
            };
            g.projectiles.push(pr);
            shootSound();
            p.canShoot = 0;
            // cooldown scales with power (higher power -> longer cooldown)
            p.attackCd = 18 + Math.round(36 * power); // 18..54
            p.attackCdMax = p.attackCd;
            p.charging = false;
            p.charge = 0;
            p.right = vx > 0 ? 1 : 0;
          }
        }
        if (p.attackCd > 0) {
          p.attackCd--;
          if (p.attackCd == 0) p.canShoot = 1
        }
        if (g.k.swing && !p.swing) {
          p.swing = 1;
          p.sf = 0;
          attackSound()
        }
        if (p.swing) {
          p.sf++;
          if (p.sf >= 15) {
            p.swing = 0;
            p.sf = 0
          }
        }
        p.vy += .6;
        p.y += p.vy;
        p.x += p.vx;
        if (p.x < g.cam + 50) p.x = g.cam + 50;
        var tc = p.x - 300;
        if (tc > g.cam) g.cam = tc;
        if (Math.abs(p.vx) > .5) p.f += .5;
        if (p.inv > 0) p.inv--;
        p.gnd = 0;
        for (var i = 0; i < g.plat.length; i++) {
          var pl = g.plat[i];
          if (p.vy >= 0 && p.x + p.w > pl.x && p.x < pl.x + pl.w && p.y + p.h >= pl.y && p.y + p.h <= pl.y + pl.h + 15) {
            // check if platform has spikes
            if (pl.spikes) {
              p.hp = 0;
              endGame();
            } else {
              p.y = pl.y - p.h;
              p.vy = 0;
              p.gnd = 1;
              p.jump = 0;
              p.jl = cls.maxJumps
            }
          }
        }
        // arrow collision - player can jump on arrows
        for (var i = 0; i < g.projectiles.length; i++) {
          var pr = g.projectiles[i];
          if ((pr.type === 'arrow' || pr.type === 'enemy_arrow') && p.vy >= 0) {
            // arrow collision box (larger than visual for easier jumping)
            var arrowCollision = {
              x: pr.x - 10,
              y: pr.y - 5,
              w: 20,
              h: 15
            };
            var playerBox = {
              x: p.x,
              y: p.y + p.h - 2,
              w: p.w,
              h: 4
            };
            if (coll(playerBox, arrowCollision)) {
              p.y = pr.y - p.h - 5;
              p.vy = 0;
              p.gnd = 1;
              p.jump = 0;
              p.jl = cls.maxJumps;
            }
          }
        }
        // enemies
        for (var i = 0; i < g.en.length; i++) {
          var e = g.en[i];
          if (e.dead) continue;
          // hunter behavior: FSM-based AI with intelligent pathfinding and jump optimization
          if (e.type === 'hunter') {
            var speed = (e.speed || 2.2);
            
            // Initialize FSM state if not set
            if (!e._state) {
              e._state = 'IDLE';
              e._stateTimer = 0;
              e._targetPlatIdx = null;
              e._jumpPrediction = null;
            }
            
            // Find current platform
            var curPlIdx = -1;
            for (var j = 0; j < g.plat.length; j++) {
              if (e.x + e.w > g.plat[j].x && e.x < g.plat[j].x + g.plat[j].w && 
                  Math.abs((e.y + e.h) - g.plat[j].y) < 8) {
                curPlIdx = j;
                break;
              }
            }
            
            var playerPlIdx = -1;
            for (var j = 0; j < g.plat.length; j++) {
              if (p.x + p.w > g.plat[j].x && p.x < g.plat[j].x + g.plat[j].w) {
                playerPlIdx = j;
                break;
              }
            }
            
            // FSM State Machine
            if (e._state === 'IDLE' || e._state === 'CALCULATING') {
              // Calculate best path to player using platform graph
              if (curPlIdx !== -1 && playerPlIdx !== -1 && curPlIdx !== playerPlIdx) {
                // Find safest path considering jump distances
                var path = findOptimalHunterPath(curPlIdx, playerPlIdx, g.plat, e.jl);
                if (path && path.length > 1) {
                  e._targetPlatIdx = path[1];
                  e._state = 'PURSUING';
                  e._stateTimer = 0;
                } else {
                  e._state = 'IDLE';
                }
              } else if (playerPlIdx !== -1 && curPlIdx === playerPlIdx) {
                // On same platform as player
                e._state = 'ATTACKING';
              } else {
                e._state = 'IDLE';
              }
            }
            
            if (e._state === 'PURSUING' && e._targetPlatIdx !== null && e.gnd) {
              var targetPl = g.plat[e._targetPlatIdx];
              var targetCx = targetPl.x + targetPl.w / 2;
              var hunterCx = e.x + e.w / 2;
              var distToTarget = Math.abs(targetCx - hunterCx);
              
              // Move toward target platform
              if (distToTarget > 20) {
                e.vx = Math.sign(targetCx - hunterCx) * speed;
              } else {
                // At edge, attempt intelligent jump
                if (e.jl > 0) {
                  var jumpValid = canJump(g.plat[curPlIdx], targetPl);
                  if (jumpValid) {
                    e.vy = -13;
                    e.gnd = 0;
                    e.jl--;
                    e._state = 'JUMPING';
                    e._stateTimer = 0;
                  }
                }
              }
            }
            
            if (e._state === 'JUMPING') {
              e._stateTimer++;
              var targetCx = e._targetPlatIdx !== null ? g.plat[e._targetPlatIdx].x + g.plat[e._targetPlatIdx].w / 2 : p.x + p.w / 2;
              var hunterCx = e.x + e.w / 2;
              var distX = targetCx - hunterCx;
              
              // Mid-air steering
              e.vx = Math.sign(distX) * speed * 1.2;
              
              // Smart double jump: use it if falling and far from target
              if (e.jl > 0 && e.vy > 1) {
                var targetPl = e._targetPlatIdx !== null ? g.plat[e._targetPlatIdx] : null;
                if (targetPl && Math.abs(distX) > 60 && Math.abs(e.y - targetPl.y) > 40) {
                  e.vy = -11;
                  e.jl--;
                }
              }
            }
            
            if (e._state === 'ATTACKING') {
              // Chase player on same platform
              var px = p.x + p.w / 2;
              var ex = e.x + e.w / 2;
              var distX = Math.abs(px - ex);
              
              if (distX > 30) {
                e.vx = Math.sign(px - ex) * speed * 1.2;
              } else {
                e.vx = 0;
              }
              
              // Recalculate if player jumps to different platform
              if (playerPlIdx !== curPlIdx && playerPlIdx !== -1) {
                e._state = 'CALCULATING';
              }
            }
            
            // Fallback: simple pursuit if state breaks
            if (e._state === 'IDLE' || !e._state) {
              var dx = p.x - e.x;
              e.vx = Math.sign(dx) * speed * 0.8;
            }
            
            // Air control
            if (!e.gnd && e.vy > 2) {
              e.vx = Math.sign(e._targetPlatIdx !== null ? 
                (g.plat[e._targetPlatIdx].x + g.plat[e._targetPlatIdx].w / 2) - (e.x + e.w / 2) : 
                p.x - e.x) * speed;
            }

            // apply physics
            e.vy = (e.vy || 0) + 0.6;
            e.y += e.vy;
            e.x += e.vx;

            // landing detection and reset
            e.gnd = 0;
            for (var j = 0; j < g.plat.length; j++) {
              var pl = g.plat[j];
              if (e.vy >= 0 && e.x + e.w > pl.x && e.x < pl.x + pl.w && e.y + e.h >= pl.y && e.y + e.h <= pl.y + pl.h + 15) {
                // check if platform has spikes - hunters fall through
                if (pl.spikes) {
                  e.dead = 1;
                } else {
                  e.y = pl.y - e.h; e.vy = 0; e.gnd = 1; e.jl = 2; e._jumpingTo = null; e._doubleJumpUsed = false;
                  // give a short think cooldown after landing so hunter commits to next step
                  e._thinkCooldown = 6;
                }
              }
            }
          } else if (e.type === 'archer') {
            // archer enemy: patrols and shoots at player
            var speed = e.speed || 1.5;
            var dx = p.x - e.x;
            
            // simple patrol
            e.x += e.vx;
            if (e.x <= e.pl || e.x + e.w >= e.pr) e.vx *= -1;
            
            // keep aligned to platform
            var plIdx = findPlatformIndexAtX(e.x, e.w);
            if (plIdx !== -1) {
              e.y = g.plat[plIdx].y - e.h;
              e.gnd = 1;
            }
            
            // shooting behavior: fire at player periodically
            e._shootCooldown--;
            if (e._shootCooldown <= 0 && Math.abs(dx) < 500) {
              // calculate angle to player
              var ex = e.x + e.w / 2;
              var ey = e.y + e.h / 2;
              var py = p.y + 20;
              var angle = Math.atan2(py - ey, (p.x - g.cam + 15) - (ex - g.cam));
              var arrowSpeed = 8;
              var vx = Math.cos(angle) * arrowSpeed;
              var vy = Math.sin(angle) * arrowSpeed;
              
              var arrow = {
                x: ex,
                y: ey,
                vx: vx,
                vy: vy,
                w: 10,
                h: 4,
                life: 100,
                type: 'enemy_arrow',
                rot: angle,
                power: 0.5
              };
              g.projectiles.push(arrow);
              e._shootCooldown = 60 + Math.floor(Math.random() * 40); // shoot every ~1-1.7 seconds
            }
            
            // apply physics
            e.vy = (e.vy || 0) + 0.6;
            e.y += e.vy;
            
            // landing detection
            e.gnd = 0;
            for (var j = 0; j < g.plat.length; j++) {
              var pl = g.plat[j];
              if (e.vy >= 0 && e.x + e.w > pl.x && e.x < pl.x + pl.w && e.y + e.h >= pl.y && e.y + e.h <= pl.y + pl.h + 15) {
                if (pl.spikes) {
                  e.dead = 1;
                } else {
                  e.y = pl.y - e.h; e.vy = 0; e.gnd = 1;
                }
              }
            }
          } else {
            // simple patrol behavior
            e.x += e.vx;
            if (e.x <= e.pl || e.x + e.w >= e.pr) e.vx *= -1;
            // ensure y aligned to platform if possible
            var plIdx = findPlatformIndexAtX(e.x, e.w);
            if (plIdx !== -1) {
              e.y = g.plat[plIdx].y - e.h;
              e.gnd = 1;
            }
          }
          // swing hit on enemy
          if (p.swing) {
            var sh = getSwHit(p);
            if (coll(sh, e)) {
              e.dead = 1;
              g.sc += (e.type === 'hunter' ? 500 : 200);
              upSc();
              coinSound();
              dropPowerup(e.x + e.w / 2, e.y);
              if (e.type === 'hunter') {
                g.hunters = g.hunters.filter(function(h) {
                  return h !== e
                });
                if (g.hunters.length === 0) g.spawnMul = 1;
              }
            }
          }
          // hunter escape: if it passes player, increase spawn rate
          if (e.type === 'hunter' && !e.escaped && e.x > g.p.x) {
            e.escaped = 1;
            g.spawnMul = 1.5;
            g.hunters.push(e);
          }
          // collision damage
          if (!e.dead && p.inv <= 0 && coll({
              x: p.x + 5,
              y: p.y + 5,
              w: p.w - 10,
              h: p.h - 5
            }, {
              x: e.x,
              y: e.y,
              w: e.w,
              h: e.h
            })) {
            p.hp--;
            p.inv = 90;
            upHp();
            damageSound();
            if (p.hp <= 0) endGame()
          }
        }
        // projectiles update & collisions
        for (var i = g.projectiles.length - 1; i >= 0; i--) {
          var pr = g.projectiles[i];
          pr.x += pr.vx;
          pr.y += (pr.vy || 0);
          pr.life--;
          
          // player arrow hits enemies
          if (pr.type === 'arrow') {
            for (var j = 0; j < g.en.length; j++) {
              var e = g.en[j];
              if (e.dead) continue;
              if (coll({
                  x: pr.x,
                  y: pr.y,
                  w: pr.w,
                  h: pr.h
                }, e)) {
                // Damage scales: fully charged shot deals 5 damage, otherwise 1
                var base = (pr.power && pr.power >= 1) ? 5 : 1;
                var dmgMul = 1 + ((g.upgrades && g.upgrades.damage) ? (0.5 * g.upgrades.damage) : 0);
                var dmg = Math.max(1, Math.round(base * dmgMul));
                e.hp = (e.hp || 1) - dmg;
                pr.life = 0;
                if (e.hp <= 0) {
                  e.dead = 1;
                  g.sc += 150;
                  upSc();
                  coinSound();
                  dropPowerup(e.x + e.w / 2, e.y, 0.25); // 25% drop rate for arrow kills
                }
              }
            }
          }
          // enemy arrow hits player
          else if (pr.type === 'enemy_arrow') {
            if (!p.dead && coll({
                x: pr.x,
                y: pr.y,
                w: pr.w,
                h: pr.h
              }, {
                x: p.x + 5,
                y: p.y + 5,
                w: p.w - 10,
                h: p.h - 5
              })) {
              p.hp--;
              p.inv = 90;
              upHp();
              damageSound();
              pr.life = 0;
              if (p.hp <= 0) endGame()
            }
          }
          
          if (pr.life <= 0) g.projectiles.splice(i, 1)
        }
        // powerup physics and collision
        for (var i = g.powerups.length - 1; i >= 0; i--) {
          var pu = g.powerups[i];
          pu.life--;
          pu.vy += 0.4; // gravity
          pu.y += pu.vy;
          pu.x += pu.vx;
          pu.vx *= 0.98; // friction
          
          // platform collision - bounce or land
          for (var j = 0; j < g.plat.length; j++) {
            var pl = g.plat[j];
            if (pu.vy >= 0 && pu.x + pu.w > pl.x && pu.x < pl.x + pl.w && pu.y + pu.h >= pl.y && pu.y + pu.h <= pl.y + pl.h + 15) {
              pu.y = pl.y - pu.h;
              pu.vy *= -0.3; // bounce
              if (Math.abs(pu.vy) < 0.5) pu.vy = 0;
            }
          }
          
          // player collision - apply powerup
          if (coll({x: p.x + 5, y: p.y + 5, w: p.w - 10, h: p.h - 5}, pu)) {
            if (pu.type === 'health') {
              var maxHp = classes[selClass].hp + (g.upgrades ? (g.upgrades.health || 0) : 0);
              p.hp = Math.min(p.hp + 2, maxHp);
              upHp();
            } else if (pu.type === 'speed') {
              p._speedBoost = 120; // 2 seconds of speed
            } else if (pu.type === 'shield') {
              p.inv = 180; // 3 seconds of invincibility
            }
            g.powerups.splice(i, 1);
          } else if (pu.life <= 0) {
            g.powerups.splice(i, 1);
          }
        }
        for (var i = 0; i < g.coinItems.length; i++) {
          var co = g.coinItems[i];
          if (!co.c) {
            var d = Math.sqrt(Math.pow(co.x - (p.x + 15), 2) + Math.pow(co.y - (p.y + 25), 2));
            if (d < co.r + 20) {
              co.c = 1;
              g.sc += 100;
              upSc();
              coinSound()
            }
          }
        }
        for (var i = 0; i < g.obs.length; i++) {
          var o = g.obs[i];
          if (p.inv <= 0 && coll({
              x: p.x + 5,
              y: p.y + 5,
              w: p.w - 10,
              h: p.h - 5
            }, o)) {
            p.hp--;
            p.inv = 90;
            upHp();
            damageSound();
            if (p.hp <= 0) endGame()
          }
        }
        if (p.y > H + 50) endGame();
        var nd = Math.floor(p.x / 50);
        if (nd > g.dist) {
          g.sc += nd - g.dist;
          g.dist = nd;
          upSc();
          updateBestDiff()
        }
        g.plat = g.plat.filter(function(p) {
          return p.x + p.w > g.cam - 200
        });
        g.coinItems = g.coinItems.filter(function(c) {
          return c.x > g.cam - 200
        });
        g.obs = g.obs.filter(function(o) {
          return o.x > g.cam - 200
        });
        g.en = g.en.filter(function(e) {
          return e.x > g.cam - 200
        });
        // Ensure we have at least one platform, regenerate if all were removed
        if (g.plat.length === 0) {
          g.plat.push({x: g.cam + 100, y: 350, w: 200, h: 15});
        }
        var lp = g.plat[g.plat.length - 1];
        if (lp && lp.x + lp.w < g.cam + W + 400) {
          var np = genPlat(lp.x + lp.w, lp);
          g.plat.push(np);
          g.pgen++;
          var co = genCoin(np);
          if (co) g.coinItems.push(co);
          var ob = genObs(np, g.pgen);
          if (ob) g.obs.push(ob);
          var e = genEn(np, g.pgen);
          if (e && Math.random() < g.spawnMul) {
            g.en.push(e);
            if (e.type === 'hunter') g.hunters.push(e)
          } else if (e) g.en.push(e)
        }
        for (var i = 0; i < g.plat.length; i++) drawPlat(g.plat[i], g.cam);
        for (var i = 0; i < g.coinItems.length; i++) drawCoin(g.coinItems[i], t, g.cam);
        for (var i = 0; i < g.obs.length; i++) drawObs(g.obs[i], g.cam);
        for (var i = 0; i < g.en.length; i++) drawEn(g.en[i], g.cam);
        // draw powerups
        for (var i = 0; i < g.powerups.length; i++) {
          var pu = g.powerups[i];
          var x = pu.x - g.cam;
          var y = pu.y;
          ctx.save();
          // spinning animation
          var angle = (t / 10) % (Math.PI * 2);
          ctx.translate(x + pu.w / 2, y + pu.h / 2);
          ctx.rotate(angle);
          
          if (pu.type === 'health') {
            // red health cross
            ctx.fillStyle = '#ef4444';
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 4;
            ctx.fillRect(-2, -6, 4, 12);
            ctx.fillRect(-6, -2, 12, 4);
          } else if (pu.type === 'speed') {
            // yellow lightning bolt
            ctx.fillStyle = '#eab308';
            ctx.shadowColor = '#ca8a04';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.moveTo(0, -7);
            ctx.lineTo(3, -1);
            ctx.lineTo(1, -1);
            ctx.lineTo(4, 7);
            ctx.lineTo(-1, 2);
            ctx.lineTo(0, 2);
            ctx.closePath();
            ctx.fill();
          } else if (pu.type === 'shield') {
            // cyan shield star
            ctx.fillStyle = '#06b6d4';
            ctx.shadowColor = '#0891b2';
            ctx.shadowBlur = 4;
            for (var s = 0; s < 5; s++) {
              var angle = (s * Math.PI * 2 / 5) - Math.PI / 2;
              var px = Math.cos(angle) * 7;
              var py = Math.sin(angle) * 7;
              if (s === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }
        for (var i = 0; i < g.projectiles.length; i++) {
          var pr = g.projectiles[i];
          ctx.save();
          if (pr.type === 'arrow' || pr.type === 'enemy_arrow') {
            // draw rotated arrow projectile
            var px = pr.x - g.cam,
              py = pr.y;
            var ang = pr.rot || Math.atan2(pr.vy || 0, pr.vx || 0);
            ctx.translate(px + pr.w / 2, py + pr.h / 2);
            ctx.rotate(ang);
            // shaft
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#ef4444' : '#f3f4f6';
            ctx.fillRect(-2, -1, 20, 2);
            // fletching
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#dc2626' : '#f59e0b';
            ctx.beginPath();
            ctx.moveTo(-2, -1);
            ctx.lineTo(-6, -5);
            ctx.lineTo(-6, 5);
            ctx.closePath();
            ctx.fill();
            // head
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#b91c1c' : '#374151';
            ctx.beginPath();
            ctx.moveTo(18, 0);
            ctx.lineTo(14, -4);
            ctx.lineTo(14, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          } else {
            // default projectile - simplified for performance
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(pr.x - g.cam, pr.y, pr.w, pr.h);
            ctx.restore();
          }
        }
        // draw target lock indicator for archer
        if (cls.ranged && g.targetLock && !g.targetLock.dead) {
          var tx = g.targetLock.x - g.cam,
            ty = g.targetLock.y + 12;
          ctx.save();
          ctx.strokeStyle = 'rgba(52,211,153,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(tx, ty, 20, 0, Math.PI * 2);
          ctx.stroke();
          var rot = (t * 0.01) % (Math.PI * 2);
          ctx.strokeStyle = 'rgba(52,211,153,0.8)';
          ctx.lineWidth = 1.5;
          for (var j = 0; j < 4; j++) {
            var angle = rot + (j * Math.PI / 2);
            var x1 = tx + Math.cos(angle) * 25;
            var y1 = ty + Math.sin(angle) * 25;
            ctx.beginPath();
            ctx.moveTo(tx + Math.cos(angle) * 22, ty + Math.sin(angle) * 22);
            ctx.lineTo(x1, y1);
            ctx.stroke();
          }
          ctx.restore();
        }
        // debug render for hunters (optional)
        if (g.showHunterDebug && typeof renderHunterDebug === 'function') renderHunterDebug(ctx, g, g.cam);
        drawStick(p, g.cam);
        } catch (err) {
          console.error('Game loop error:', err);
          // Continue loop even on error
          anim = requestAnimationFrame(loop);
        }
      }

      function startGame() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        init();
        anim = requestAnimationFrame(loop)
      }

      function restart() {
        document.getElementById('over').classList.add('hidden');
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        if (anim) cancelAnimationFrame(anim);
        init();
        anim = requestAnimationFrame(loop)
      }

      function clearHighScore() {
        if (confirm('Clear high score? This cannot be undone.')) {
          g.hi = 0;
          setCookie('highScore', 0);
          document.getElementById('highScoreDisplay').value = '0';
          upSc()
        }
      }

      function key(k, v) {
        g.k[k] = v
      }
      window.addEventListener('keydown', function(e) {
        if (e.key == 'ArrowLeft' || e.key == 'a' || e.key == 'A') g.k.left = 1;
        if (e.key == 'ArrowRight' || e.key == 'd' || e.key == 'D') g.k.right = 1;
        if (e.key == 'ArrowUp' || e.key == 'w' || e.key == 'W' || e.key == ' ') {
          e.preventDefault();
          g.k.up = 1
        }
        if (e.key == 'Shift') {
          e.preventDefault();
          g.k.swing = 1
        }
        if (e.key == 'k' || e.key == 'K') {
          if (!e.repeat) g.k.attack = 1
        }
        if ('123'.includes(e.key)) {
          selectClass(parseInt(e.key) - 1)
        }
      });
      window.addEventListener('keyup', function(e) {
        if (e.key == 'ArrowLeft' || e.key == 'a' || e.key == 'A') g.k.left = 0;
        if (e.key == 'ArrowRight' || e.key == 'd' || e.key == 'D') g.k.right = 0;
        if (e.key == 'ArrowUp' || e.key == 'w' || e.key == 'W' || e.key == ' ') g.k.up = 0;
        if (e.key == 'Shift') g.k.swing = 0;
        if (e.key == 'k' || e.key == 'K') g.k.attack = 0;
      });
      // reset input state on window blur to prevent stuck keys
      window.addEventListener('blur', function() {
        g.k = {
          left: 0,
          right: 0,
          up: 0,
          swing: 0,
          attack: 0
        };
      });
      // Initialize on load
      updateClassUI();
      drawClassPreview();
      drawMainMenuCharPreview();
      document.getElementById('highScoreDisplay').value = g.hi;
      document.getElementById('highScoreDisplay2').textContent = g.hi;
      document.getElementById('volumeSlider').value = soundVolume;
    </script>
  </body>
</html>