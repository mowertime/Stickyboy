
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Stickman Run</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #0f172a;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        color: #fff
      }

      #gameContainer {
        position: relative;
        width: 100%;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex: 1;
        min-height: 0
      }

      #gameCanvas {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        border: 2px solid rgba(34, 211, 238, 0.3);
        border-radius: 16px;
        display: block;
        box-shadow: 0 0 50px rgba(34, 211, 238, 0.2);
        background: #000
      }

      .hud {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        justify-content: center;
        padding: 4px 8px;
        background: rgba(15, 23, 42, 0.8);
        border-radius: 8px;
        border: 1px solid rgba(34, 211, 238, 0.2)
      }

      /* Best distance display in HUD */
      #bestDiffBar {
        background: rgba(2, 6, 23, 0.7);
        padding: 6px 12px;
        border-radius: 12px;
        border: 1px solid rgba(34, 211, 238, 0.12);
        font-weight: 700;
        color: #cbd5e1;
        font-size: 14px
      }

      @media(max-width:600px) {

        /* on small screens move the bar further down so it doesn't collide with wrapped HUD */
        #bestDiffBar {
          top: 88px;
          padding: 8px 14px;
          font-size: 14px
        }
      }

      /* top-right HUD buttons (Upgrades / Settings) */
      #hudTopRight {
        display: flex;
        gap: 8px;
        margin-left: auto
      }

      .stat {
        background: rgba(30, 41, 59, 0.9);
        padding: 2px 8px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 4px;
        font-weight: bold;
        font-size: 14px
      }

      #healthStat {
        flex-direction: row;
        align-items: center
      }

      #healthBar {
        width: 100px;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(239, 68, 68, 0.8);
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0
      }

      #healthBarFill {
        height: 100%;
        background: linear-gradient(to right, #ef4444, #f87171);
        width: 100%;
        transition: width 0.15s ease;
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3), 0 0 8px rgba(239, 68, 68, 0.6)
      }

      #mainMenu {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        border-radius: 0;
        z-index: 20;
        padding: 20px;
        gap: 20px;
        flex-wrap: wrap
      }

      .hidden {
        display: none !important
      }

      /* common overlay base to center modal-like screens */
      .overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        padding: 20px;
        background: rgba(15, 23, 42, 0.95)
      }

      #charPreviewSection {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        flex: 0 0 auto;
        max-width: 260px
      }

      #charPreviewCanvas {
        border: 3px solid rgba(52, 211, 153, 0.5);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.3)
      }

      .changeCharBtn {
        background: linear-gradient(to right, #34d399, #10b981);
        color: #fff;
        border: none;
        padding: 12px 24px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 8px 20px rgba(52, 211, 153, 0.3);
        transition: all 0.2s
      }

      .changeCharBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 30px rgba(52, 211, 153, 0.5)
      }

      #mainMenuCenter {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 24px;
        flex: 1;
        min-width: 260px;
        max-width: 500px
      }

      #highScoreDisplay2 {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center
      }

      #highScoreLabel {
        font-size: 18px;
        color: #94a3b8;
        margin-bottom: -16px
      }

      .startGameBtn {
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        color: #fff;
        border: none;
        padding: 20px 60px;
        border-radius: 30px;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3);
        transition: all 0.2s
      }

      .startGameBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(34, 211, 238, 0.5)
      }

      /* Canvas wrapper for overlays */
      #canvasWrapper {
        position: relative;
        width: 100%;
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center
      }

      /* Upgrades UI */
      .upgradeOverlay {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.92);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 21;
        padding: 24px;
        border-radius: 12px
      }

      .upgradeGrid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 18px;
        width: 80%;
        max-width: 720px
      }

      .upgradeItem {
        background: rgba(30, 41, 59, 0.9);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(34, 211, 238, 0.08);
        text-align: center
      }

      .upgradeItem h3 {
        margin: 6px 0 8px 0
      }

      .upgradeItem p {
        margin: 6px 0;
        color: #94a3b8
      }

      .upgradeBtn {
        background: linear-gradient(to right, #34d399, #10b981);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold
      }

      .upgradeBtn[disabled] {
        opacity: 0.45;
        cursor: not-allowed
      }

      .upClose {
        position: absolute;
        top: 18px;
        right: 18px;
        background: linear-gradient(to right, #ef4444, #dc2626);
        border: none;
        color: #fff;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer
      }

      #settingsTopRight {
        position: absolute;
        top: 40px;
        right: 40px
      }

      .settingsBtn {
        background: linear-gradient(to right, #64748b, #475569);
        color: #fff;
        border: none;
        padding: 12px 24px;
        border-radius: 20px;
        font-size: 16px;
        cursor: pointer;
        box-shadow: 0 8px 20px rgba(100, 116, 139, 0.3);
        transition: all 0.2s
      }

      .settingsBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 30px rgba(100, 116, 139, 0.5)
      }

      .settingsGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
        text-align: left
      }

      .settingItem {
        background: rgba(30, 41, 59, 0.6);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(52, 211, 153, 0.3)
      }

      .settingItem label {
        display: block;
        margin-bottom: 8px;
        color: #94a3b8;
        font-size: 14px
      }

      .settingItem input {
        width: 100%;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(52, 211, 153, 0.5);
        border-radius: 6px;
        color: #fff
      }

      h1 {
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 16px
      }

      h2 {
        font-size: 36px;
        color: #ef4444;
        margin-bottom: 16px
      }

      .instructions {
        color: #94a3b8;
        text-align: center;
        margin-bottom: 32px;
        line-height: 1.6;
        padding: 0 16px
      }

      .classSelectOverlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 0;
        z-index: 20;
        padding: 20px;
        overflow-y: auto
      }

      .classSelectOverlay > * {
        max-width: 900px;
        width: 100%
      }

      .menuButton {
        background: linear-gradient(to right, #22d3ee, #3b82f6);
        color: #fff;
        border: none;
        padding: 16px 32px;
        border-radius: 30px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3);
        margin: 12px;
        min-width: 200px;
        transition: all 0.2s
      }

      .menuButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(34, 211, 238, 0.5)
      }

      .controls {
        display: none;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
        justify-content: center
      }

      @media(max-width:768px) {
        .controls {
          display: flex
        }

        h1 {
          font-size: 32px
        }
      }

      @media(max-width:900px) {
        #mainMenu {
          flex-direction: column;
          padding: 20px
        }

        #charPreviewSection,
        #mainMenuCenter {
          width: 100%;
          text-align: center
        }

        .upgradeGrid {
          grid-template-columns: repeat(1, 1fr);
          width: 95%
        }

        #hudTopRight {
          top: 12px;
          right: 12px
        }
      }

      .control-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(30, 41, 59, 0.8);
        border: 2px solid rgba(34, 211, 238, 0.5);
        color: #22d3ee;
        font-size: 20px;
        padding: 0
      }

      .jump {
        width: 64px;
        border-color: rgba(251, 191, 36, 0.5);
        color: #fbbf24;
        font-size: 14px
      }

      .attack {
        width: 64px;
        border-color: rgba(59, 130, 246, 0.5);
        color: #3b82f6;
        font-size: 24px
      }

      .heart {
        font-size: 20px
      }

      .empty {
        opacity: 0.3
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div class="hud">
        <div class="stat">
          <span>üí∞</span>
          <span id="coins">0</span>
        </div>
        <div class="stat">
          <span>ü™ô</span>
          <span id="score">0</span>
        </div>
        <div class="stat">
          <span>üèÜ</span>
          <span id="high">0</span>
        </div>
        <div class="stat" id="healthStat">
          <span>‚ù§Ô∏è</span>
          <div id="healthBar">
            <div id="healthBarFill"></div>
          </div>
        </div>
      </div>
      <div id="bestDiffBar">Distance to best: 0</div>
      <div id="hudTopRight">
        <button class="settingsBtn" onclick="goToUpgrades()">üõ† UPGRADES</button>
        <button class="settingsBtn" onclick="toggleFullscreen()" id="fullscreenBtn">‚õ∂</button>
      </div>
      <div id="canvasWrapper">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>
    <canvas id="previewCanvas" width="800" height="500" style="display:none"></canvas>
    <div id="mainMenu" class="overlay classSelectOverlay">
        <div id="charPreviewSection">
          <canvas id="charPreviewCanvas" width="250" height="280" style="display:block"></canvas>
          <button class="changeCharBtn" onclick="goToClassSelect()">‚öô CHANGE CHARACTER</button>
        </div>
        <div id="mainMenuCenter">
          <div>
            <p id="highScoreLabel">üèÜ HIGH SCORE</p>
            <div id="highScoreDisplay2">0</div>
          </div>
          <button class="startGameBtn" onclick="startFromMainMenu()">‚ñ∂ START GAME</button>
          <button class="menuButton" onclick="goToUpgrades()">üõ† UPGRADES</button>
        </div>
        <div id="settingsTopRight">
          <button class="settingsBtn" onclick="goToSettings()">‚öô SETTINGS</button>
        </div>
      </div>
      <div id="classSelect" class="overlay classSelectOverlay hidden">
        <h1>SELECT YOUR CLASS</h1>
        <p class="instructions">Choose a class to see its abilities</p>
        <div id="previewContainer" style="width:100%;height:300px;margin:20px 0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.2);border-radius:12px;position:relative">
          <canvas id="classPreview" width="300" height="250" style="display:block"></canvas>
        </div>
        <div style="display:flex;gap:12px;margin-bottom:18px;flex-wrap:wrap;justify-content:center">
          <button id="class0" onclick="selectClass(0)" style="min-width:140px">1 ‚Ä¢ Runner <br>
            <small>Triple Jump</small>
          </button>
          <button id="class1" onclick="selectClass(1)" style="min-width:140px">2 ‚Ä¢ Archer <br>
            <small>Ranged Attack</small>
          </button>
          <button id="class2" onclick="selectClass(2)" style="min-width:140px">3 ‚Ä¢ Tank <br>
            <small>More Health</small>
          </button>
        </div>
        <button class="menuButton" onclick="startGame()">‚ñ∂ START GAME</button>
        <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569)">‚Üê BACK</button>
      </div>
      <div id="settings" class="overlay classSelectOverlay hidden">
        <div style="max-width:760px;width:100%;background:rgba(2,6,23,0.92);padding:20px;border-radius:12px">
          <h1>SETTINGS</h1>
          <div class="settingsGrid">
            <div class="settingItem">
              <label>Master Volume</label>
              <input type="range" id="volumeSlider" min="0" max="100" value="100" onchange="setSoundVolume(this.value)">
            </div>
            <div class="settingItem">
              <label>High Score</label>
              <input type="text" id="highScoreDisplay" readonly>
            </div>
            <div class="settingItem">
              <label>Jump Key</label>
              <input type="text" id="jumpKeyDisplay" value="SPACE / W / ‚Üë" readonly>
            </div>
            <div class="settingItem">
              <label>Debug Hunter AI</label>
              <div style="display:flex;align-items:center;gap:8px">
                <input type="checkbox" id="debugHuntersCheckbox" onchange="toggleHunterDebug(this.checked)">
                <small style="color:#94a3b8">Draw hunter path and targets</small>
              </div>
            </div>
            <div class="settingItem">
              <label>Attack Key</label>
              <input type="text" id="attackKeyDisplay" value="SHIFT / K" readonly>
            </div>
          </div>
          <div style="margin-top:24px;text-align:center;color:#94a3b8">
            <p style="margin:8px 0">Move: A/D or ‚Üê ‚Üí</p>
            <p style="margin:8px 0">All controls are fixed</p>
          </div>
          <div style="display:flex;gap:12px;justify-content:center;margin-top:16px">
            <button class="menuButton" onclick="clearHighScore()" style="background:linear-gradient(to right,#ef4444,#dc2626);">üóë CLEAR HIGH SCORE</button>
            <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569)">‚Üê BACK</button>
          </div>
        </div>
      </div>
      <!-- Upgrades Overlay -->
      <div id="upgrades" class="upgradeOverlay hidden">
        <button class="upClose" onclick="closeUpgrades()">‚úï</button>
        <h1 style="margin-bottom:6px">UPGRADES</h1>
        <p class="instructions">Spend coins to buy permanent upgrades. Costs scale per level.</p>
        <div class="upgradeGrid">
          <div class="upgradeItem">
            <h3>Damage</h3>
            <p id="upgDamageDesc">Increase weapon damage.</p>
            <p>Level: <span id="upgDamageLevel">0</span>
            </p>
            <p>Cost: <strong id="upgDamageCost">0</strong>
            </p>
            <button id="buyDamage" class="upgradeBtn" onclick="buyUpgrade('damage')">BUY</button>
          </div>
          <div class="upgradeItem">
            <h3>Speed</h3>
            <p id="upgSpeedDesc">Increase run speed (+8% per level).</p>
            <p>Level: <span id="upgSpeedLevel">0</span>
            </p>
            <p>Cost: <strong id="upgSpeedCost">0</strong>
            </p>
            <button id="buySpeed" class="upgradeBtn" onclick="buyUpgrade('speed')">BUY</button>
          </div>
          <div class="upgradeItem">
            <h3>Health</h3>
            <p id="upgHealthDesc">Increase max HP by +1 per level.</p>
            <p>Level: <span id="upgHealthLevel">0</span>
            </p>
            <p>Cost: <strong id="upgHealthCost">0</strong>
            </p>
            <button id="buyHealth" class="upgradeBtn" onclick="buyUpgrade('health')">BUY</button>
          </div>
        </div>
      </div>
      <div id="over" class="overlay classSelectOverlay hidden">
        <h2>GAME OVER</h2>
        <p style="font-size:24px;margin-bottom:32px">ü™ô Score: <span id="final">0</span>
          <br>üèÜ Best: <span id="best">0</span>
        </p>
        <p class="instructions" style="margin-bottom:12px">Choose a different class to try again</p>
        <div style="display:flex;gap:12px;margin-bottom:18px;flex-wrap:wrap;justify-content:center">
          <button id="classEnd0" onclick="selectClassAndRestart(0)" style="min-width:120px">Runner <br>
            <small>Triple Jump</small>
          </button>
          <button id="classEnd1" onclick="selectClassAndRestart(1)" style="min-width:120px">Archer <br>
            <small>Ranged Attack</small>
          </button>
          <button id="classEnd2" onclick="selectClassAndRestart(2)" style="min-width:120px">Tank <br>
            <small>More Health</small>
          </button>
        </div>
        <button class="menuButton" onclick="goToMainMenu()" style="background:linear-gradient(to right,#64748b,#475569);margin-top:12px">‚Üê MAIN MENU</button>
      </div>
    <div class="controls">
      <button class="control-btn" onmousedown="key('left',1)" onmouseup="key('left',0)" ontouchstart="key('left',1)" ontouchend="key('left',0)">‚Üê</button>
      <button class="control-btn jump" onmousedown="key('up',1)" onmouseup="key('up',0)" ontouchstart="key('up',1)" ontouchend="key('up',0)">JUMP</button>
      <button class="control-btn attack" onmousedown="key('swing',1)" onmouseup="key('swing',0)" ontouchstart="key('swing',1)" ontouchend="key('swing',0)">‚öîÔ∏è</button>
      <button class="control-btn" onmousedown="key('right',1)" onmouseup="key('right',0)" ontouchstart="key('right',1)" ontouchend="key('right',0)">‚Üí</button>
    </div>
    <p style="color:#64748b;font-size:10px;margin:0;padding:2px 0">‚Üê ‚Üí or A/D to move ‚Ä¢ ‚Üë or W or SPACE to jump ‚Ä¢ SHIFT to attack</p>
    <div id="errorLog" style="display:none;position:fixed;bottom:10px;right:10px;background:rgba(239,68,68,0.95);color:#fff;padding:12px 16px;border-radius:8px;max-width:400px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;z-index:9999;box-shadow:0 4px 12px rgba(0,0,0,0.5)">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong>üêõ Error Log</strong>
        <button onclick="document.getElementById('errorLog').style.display='none'" style="background:#dc2626;border:none;color:#fff;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px">‚úï</button>
      </div>
      <div id="errorLogContent"></div>
    </div>
    <button onclick="toggleErrorLog()" style="position:fixed;bottom:10px;right:10px;background:rgba(100,116,139,0.8);color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:11px;z-index:1000;font-family:Arial">üìã Logs</button>
    <script src="ai_hunter.js"></script>
    <script>
      // Error logging system
      var errorLog = [];
      function logError(msg, err) {
        var timestamp = new Date().toLocaleTimeString();
        var entry = timestamp + ' - ' + msg + (err ? ': ' + err.message : '');
        errorLog.push(entry);
        console.error(entry, err);
        updateErrorLogDisplay();
        document.getElementById('errorLog').style.display = 'block';
      }
      function updateErrorLogDisplay() {
        var content = document.getElementById('errorLogContent');
        if (content) {
          content.innerHTML = errorLog.slice(-10).map(function(e) {
            return '<div style="margin:4px 0;padding:4px;background:rgba(0,0,0,0.3);border-radius:4px">' + e + '</div>';
          }).join('');
        }
      }
      function toggleErrorLog() {
        var log = document.getElementById('errorLog');
        log.style.display = log.style.display === 'none' ? 'block' : 'none';
      }
      // core setup
      var c = document.getElementById('gameCanvas'),
        ctx = c.getContext('2d'),
        W = 800,
        H = 500;
      
      // Function to resize canvas to fit screen
      function resizeCanvas() {
        var wrapper = document.getElementById('canvasWrapper');
        if (!wrapper) return;
        
        var wrapperRect = wrapper.getBoundingClientRect();
        var availableWidth = wrapperRect.width - 10; // Minimal margin for wider canvas
        var availableHeight = wrapperRect.height - 10;
        
        // Allow wider aspect ratio (2:1 instead of strict 16:10)
        var minAspectRatio = 1.5; // Minimum width:height ratio
        var maxAspectRatio = 2.2; // Maximum width:height ratio
        var targetAspectRatio = availableWidth / availableHeight;
        
        // Clamp aspect ratio within bounds
        if (targetAspectRatio < minAspectRatio) targetAspectRatio = minAspectRatio;
        if (targetAspectRatio > maxAspectRatio) targetAspectRatio = maxAspectRatio;
        
        var newWidth = availableWidth;
        var newHeight = newWidth / targetAspectRatio;
        
        if (newHeight > availableHeight) {
          newHeight = availableHeight;
          newWidth = newHeight * targetAspectRatio;
        }
        
        // Ensure minimum size
        if (newWidth < 400) newWidth = 400;
        if (newHeight < 250) newHeight = 250;
        
        // Set canvas dimensions
        c.width = Math.floor(newWidth);
        c.height = Math.floor(newHeight);
        
        // Update game dimensions
        W = c.width;
        H = c.height;
      }
      
      // Initial resize
      resizeCanvas();
      setTimeout(resizeCanvas, 100);
      setTimeout(resizeCanvas, 500);
      
      // Resize on window resize
      window.addEventListener('resize', function() {
        resizeCanvas();
      });
      // Cookie management
      function getCookie(name) {
        var nameEQ = name + "=";
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
          var cookie = cookies[i].trim();
          if (cookie.indexOf(nameEQ) === 0) return parseInt(cookie.substring(nameEQ.length));
        }
        return 0;
      }

      function setCookie(name, value, days) {
        days = days || 365;
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toUTCString();
        document.cookie = name + "=" + value + expires + "; path=/";
      }
      // Audio context for sound effects
      var audioCtx = null,
        soundVolume = getCookie('soundVolume') || 100;

      function getAudioContext() {
        if (!audioCtx) {
          audioCtx = new(window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      }

      function setSoundVolume(val) {
        soundVolume = val;
        setCookie('soundVolume', val);
        document.getElementById('volumeSlider').value = val;
      }
      // Sound effect functions
      function playSound(freq, duration, type) {
        try {
          var ctx = getAudioContext();
          if (ctx.state === 'suspended') {
            ctx.resume();
          }
          var osc = ctx.createOscillator(),
            env = ctx.createGain();
          osc.type = type || 'sine';
          osc.frequency.value = freq;
          var volumeGain = soundVolume / 100;
          env.gain.setValueAtTime(0.3 * volumeGain, ctx.currentTime);
          env.gain.exponentialRampToValueAtTime(0.01 * volumeGain, ctx.currentTime + duration);
          osc.connect(env);
          env.connect(ctx.destination);
          osc.start(ctx.currentTime);
          osc.stop(ctx.currentTime + duration);
        } catch (e) {}
      }

      function jumpSound() {
        playSound(400, 0.1, 'sine');
      }

      function coinSound() {
        playSound(800, 0.15, 'sine');
        playSound(1000, 0.1, 'sine');
      }

      function attackSound() {
        playSound(200, 0.08, 'square');
      }

      function damageSound() {
        playSound(150, 0.2, 'sine');
      }

      function gameOverSound() {
        playSound(200, 0.15, 'sine');
        playSound(150, 0.15, 'sine');
      }

      function shootSound() {
        playSound(600, 0.05, 'square');
      }
      // player classes
      var classes = [{
        id: 'Runner',
        desc: 'Triple jump',
        maxJumps: 3,
        hp: 3,
        ranged: false,
        color: '#60a5fa'
      }, {
        id: 'Archer',
        desc: 'Ranged attack',
        maxJumps: 2,
        hp: 2,
        ranged: true,
        color: '#34d399'
      }, {
        id: 'Tank',
        desc: 'More health',
        maxJumps: 2,
        hp: 5,
        ranged: false,
        color: '#f87171'
      }];
      var selClass = 0;
      var g = {
          p: null,
          plat: [],
          coinItems: [],
          obs: [],
          en: [],
          projectiles: [],
          sc: 0,
          dist: 0,
          coins: 0,
          cam: 0,
          pgen: 0,
          over: 0,
          start: 0,
          k: {
            left: 0,
            right: 0,
            up: 0,
            swing: 0,
            attack: 0
          },
          hi: getCookie('highScore') || 0,
          bestDist: Number(getCookie('bestDist') || 0),
          targetLock: null,
          hunters: [],
          spawnMul: 1,
          showHunterDebug: (getCookie('showHunterDebug') ? true : false)
        },
        anim = null;

      function rnd(a, b) {
        return Math.random() * (b - a) + a
      }
      
      // A* pathfinding for platform navigation (Minecraft-style)
      function findPlatformPathAStar(startIdx, goalIdx, platforms) {
        if (startIdx === -1 || goalIdx === -1 || startIdx === goalIdx) return null;
        if (!platforms[startIdx] || !platforms[goalIdx]) return null;
        
        // Heuristic: Manhattan distance between platform centers
        function heuristic(idx1, idx2) {
          var p1 = platforms[idx1], p2 = platforms[idx2];
          if (!p1 || !p2) return 9999;
          return Math.abs((p1.x + p1.w/2) - (p2.x + p2.w/2)) + Math.abs(p1.y - p2.y);
        }
        
        // Check if there's a safe landing platform below a point
        function hasPlatformBelow(x, y, maxFallDist) {
          for (var i = 0; i < platforms.length; i++) {
            var plat = platforms[i];
            if (!plat) continue;
            // Check if point is above platform horizontally
            if (x >= plat.x && x <= plat.x + plat.w) {
              // Check if platform is below but within safe fall distance
              if (plat.y > y && plat.y - y < maxFallDist) {
                return !plat.spikes; // platform exists and is safe (no spikes)
              }
            }
          }
          return false; // no platform found = void (value 0)
        }
        
        // Check if we can safely jump from platform A to B
        function canSafelyJump(fromIdx, toIdx) {
          var from = platforms[fromIdx], to = platforms[toIdx];
          if (!from || !to) return false; // invalid platforms (value 0)
          
          // Don't jump to spike platforms
          if (to.spikes) return false; // unsafe platform (value 0)
          
          // Calculate gap and height difference
          var gap = to.x > from.x ? 
            (to.x - (from.x + from.w)) : 
            (from.x - (to.x + to.w));
          var heightDiff = from.y - to.y; // positive if jumping up
          
          // Can't jump too far horizontally (max ~200px for safety)
          if (gap > 200) return false; // unreachable (value 0)
          
          // Can't jump too high (max ~140px)
          if (heightDiff > 140) return false; // unreachable (value 0)
          
          // Check if falling down - must have safe landing
          if (heightDiff < 0) { // jumping down
            var fallDist = Math.abs(heightDiff);
            if (fallDist > 150) return false; // too far to fall safely (value 0)
            
            // Verify there's actually a platform to land on (not void)
            var targetX = to.x + to.w / 2;
            if (!hasPlatformBelow(targetX, from.y, 200)) {
              return false; // void below - don't jump (value 0)
            }
          }
          
          // For horizontal or upward jumps, check the gap
          if (gap > 20) {
            // Check if there's void in the gap by sampling points
            var jumpMidX = from.x > to.x ? 
              from.x - gap / 2 : 
              from.x + from.w + gap / 2;
            var jumpMidY = from.y - 50; // approximate jump arc height
            
            // Make sure there's a platform below the jump arc
            if (!hasPlatformBelow(jumpMidX, jumpMidY, 300)) {
              return false; // void in jump path (value 0)
            }
          }
          
          return true; // safe jump (value 1)
        }
        
        // Get neighbors (reachable platforms)
        function getNeighbors(idx) {
          var neighbors = [];
          var current = platforms[idx];
          if (!current) return neighbors;
          
          for (var i = 0; i < platforms.length; i++) {
            if (i === idx || !platforms[i]) continue;
            if (canSafelyJump(idx, i)) {
              neighbors.push(i); // valid neighbor (value 1)
            }
          }
          return neighbors;
        }
        
        // A* algorithm
        var openSet = [startIdx];
        var cameFrom = {};
        var gScore = {};
        var fScore = {};
        
        for (var i = 0; i < platforms.length; i++) {
          gScore[i] = 9999;
          fScore[i] = 9999;
        }
        gScore[startIdx] = 0;
        fScore[startIdx] = heuristic(startIdx, goalIdx);
        
        var iterations = 0;
        var maxIterations = 100; // prevent infinite loops
        
        while (openSet.length > 0 && iterations < maxIterations) {
          iterations++;
          
          // Find node in openSet with lowest fScore
          var current = openSet[0];
          var lowestF = fScore[current];
          for (var i = 1; i < openSet.length; i++) {
            if (fScore[openSet[i]] < lowestF) {
              current = openSet[i];
              lowestF = fScore[current];
            }
          }
          
          // Reached goal
          if (current === goalIdx) {
            // Reconstruct path
            var path = [current];
            while (cameFrom[current] !== undefined) {
              current = cameFrom[current];
              path.unshift(current);
            }
            return path;
          }
          
          // Remove current from openSet
          openSet.splice(openSet.indexOf(current), 1);
          
          // Check neighbors
          var neighbors = getNeighbors(current);
          for (var i = 0; i < neighbors.length; i++) {
            var neighbor = neighbors[i];
            var tentativeG = gScore[current] + heuristic(current, neighbor);
            
            if (tentativeG < gScore[neighbor]) {
              cameFrom[neighbor] = current;
              gScore[neighbor] = tentativeG;
              fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goalIdx);
              
              if (openSet.indexOf(neighbor) === -1) {
                openSet.push(neighbor);
              }
            }
          }
        }
        
        return null; // No path found - void blocks the way (value 0)
      }

      function genPlat(x, prevPlat) {
        var gap = rnd(80, 180),
          w = Math.random() > .7 ? rnd(180, 280) : rnd(80, 180),
          y = rnd(200, 400);
        // only add spikes if previous platform didn't have them (ensure at least 1 normal platform between spikes)
        var hasSpikes = prevPlat && !prevPlat.spikes ? Math.random() > 0.75 : false;
        return {
          x: x + gap,
          y: y,
          w: w,
          h: 15,
          spikes: hasSpikes
        }
      }

      function genCoin(p) {
        if (Math.random() > .6) return {
          x: p.x + p.w / 2,
          y: p.y - 40,
          r: 12,
          c: 0
        };
        return null
      }

      function genObs(p, i) {
        if (i < 10 || Math.random() > .7 || p.w < 100) return null;
        return {
          x: p.x + rnd(15, p.w - 45),
          y: p.y - 25,
          w: 20,
          h: 25
        }
      }

      function dropPowerup(x, y, dropRate) {
        // dropRate: 0.4 = 40%, 0.25 = 25%, etc. Default is 40%
        dropRate = dropRate || 0.4;
        if (Math.random() > (1 - dropRate)) return;
        var types = ['health', 'speed', 'shield'];
        var type = types[Math.floor(Math.random() * types.length)];
        var powerup = {
          x: x,
          y: y,
          w: 15,
          h: 15,
          type: type,
          vx: (Math.random() - 0.5) * 3,
          vy: -5,
          life: 300 // 5 seconds at 60fps
        };
        g.powerups.push(powerup);
      }

      function genEn(p, i) {
        if (i < 5 || p.w < 150 || Math.random() > .5) return null;
        var rand = Math.random();
        var type = 'normal';
        if (rand > 0.75) type = 'hunter';
        else if (rand > 0.65) type = 'spider'; // 10% chance for spider
        else if (rand > 0.55) type = 'archer'; // 10% chance for archer
        
        // Randomly determine weapon tier for normal enemies
        var weaponTier = 0; // 0 = unarmed, 1 = knife, 2 = sword
        if (type === 'normal') {
          var tierRand = Math.random();
          if (tierRand > 0.8) weaponTier = 2; // 20% chance for sword
          else if (tierRand > 0.5) weaponTier = 1; // 30% chance for knife
          // else 50% chance for unarmed
        }
        
        var en = {
          x: p.x + p.w / 2,
          y: p.y - 40,
          w: 25,
          h: 40,
          vx: (Math.random() > .5 ? 1 : -1) * 2,
          pl: p.x,
          pr: p.x + p.w,
          dead: 0,
          hp: 2,
          type: type,
          escaped: 0,
          vy: 0,
          gnd: 0,
          jl: 0,
          weaponTier: weaponTier,
          attacking: 0,
          attackFrame: 0,
          attackCooldown: 0,
          // AI state
          _path: null,
          _pathTimer: 0,
          _thinkCooldown: 0,
          _jumpingTo: null,
          _doubleJumpUsed: false,
          // archer state
          _shootCooldown: 0
        };
        if (type === 'hunter') {
          en.hp = 3;
          en.speed = 2.5;
          en.jl = 2;
          en.maxJumps = 2;
          en._platformPath = null;
          en._pathIndex = 0;
          en._recalcTimer = 0;
          en._targetPlatform = null;
          en._stuckTimer = 0;
          en._lastX = 0;
          // Spawn hunters directly on platform to prevent falling
          en.y = p.y - en.h;
          en.gnd = 1;
          en.vx = 0; // start stationary
        } else if (type === 'archer') {
          en.hp = 2;
          en.speed = 1.5;
          en._shootCooldown = 0;
        } else if (type === 'spider') {
          en.hp = 2;
          en.speed = 1.2;
          en.w = 40;
          en.h = 35;
          en._shootCooldown = 90; // initial cooldown
          en.y = p.y - p.h - 120; // spawn higher above platform (out of reach)
          en.onCeiling = true;
          en._swinging = false;
          en._swingTimer = 0;
          en._swingAngle = 0;
          en._swingSpeed = 0;
          en._anchorX = 0;
          en._anchorY = 0;
          en._swingLen = 80; // dynamic web length
          en._attackMode = 'shoot'; // 'shoot' or 'swing'
        }
        return en
      }

      function selectClass(i) {
        selClass = i;
        updateClassUI();
        drawClassPreview();
        drawMainMenuCharPreview()
      }

      function updateClassUI() { // highlight selected
        for (var i = 0; i < 3; i++) {
          var btn = document.getElementById('class' + i);
          if (!btn) continue;
          btn.style.outline = (i === selClass) ? '3px solid rgba(255,255,255,0.12)' : '';
          var bEnd = document.getElementById('classEnd' + i);
          if (bEnd) bEnd.style.outline = (i === selClass) ? '3px solid rgba(255,255,255,0.12)' : ''
        }
      }

      function goToMainMenu() {
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
        drawMainMenuCharPreview()
      }

      function goToClassSelect() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('classSelect').classList.remove('hidden');
        drawClassPreview()
      }

      function goToSettings() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.remove('hidden');
        document.getElementById('highScoreDisplay').value = g.hi;
        document.getElementById('volumeSlider').value = soundVolume;
        loadSettings();
      }

      function drawMainMenuCharPreview() {
        var canvas = document.getElementById('charPreviewCanvas');
        if (!canvas) return;
        var pctx = canvas.getContext('2d');
        var cls = classes[selClass];
        pctx.fillStyle = '#071022';
        pctx.fillRect(0, 0, canvas.width, canvas.height);
        var cx = canvas.width / 2,
          cy = canvas.height / 2 - 20;
        pctx.save();
        pctx.strokeStyle = cls.color;
        pctx.lineWidth = 4;
        pctx.lineCap = 'round';
        pctx.beginPath();
        pctx.arc(cx, cy - 25, 15, 0, Math.PI * 2);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy);
        pctx.lineTo(cx, cy + 35);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 10);
        pctx.lineTo(cx - 20, cy + 25);
        pctx.moveTo(cx, cy + 10);
        pctx.lineTo(cx + 20, cy + 25);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 35);
        pctx.lineTo(cx - 15, cy + 60);
        pctx.moveTo(cx, cy + 35);
        pctx.lineTo(cx + 15, cy + 60);
        pctx.stroke();
        pctx.restore();
        pctx.fillStyle = '#fff';
        pctx.font = 'bold 20px Arial';
        pctx.textAlign = 'center';
        pctx.fillText(cls.id, cx, cy + 100);
        pctx.font = '14px Arial';
        pctx.fillStyle = cls.color;
        pctx.fillText('‚ù§Ô∏è HP: ' + cls.hp, cx, cy + 125);
        pctx.fillText('‚¨ÜÔ∏è Jumps: ' + cls.maxJumps, cx, cy + 145);
      }

      function startFromMainMenu() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        init();
        anim = requestAnimationFrame(loop)
      }

      function drawClassPreview() {
        var pcanvas = document.getElementById('classPreview');
        if (!pcanvas) return;
        var pctx = pcanvas.getContext('2d');
        var cls = classes[selClass];
        pctx.fillStyle = '#071022';
        pctx.fillRect(0, 0, pcanvas.width, pcanvas.height);
        var cx = pcanvas.width / 2,
          cy = pcanvas.height / 2 - 20;
        // draw stick figure
        pctx.save();
        pctx.strokeStyle = cls.color;
        pctx.lineWidth = 3;
        pctx.lineCap = 'round';
        pctx.beginPath();
        pctx.arc(cx, cy - 20, 12, 0, Math.PI * 2);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy);
        pctx.lineTo(cx, cy + 25);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 8);
        pctx.lineTo(cx - 15, cy + 20);
        pctx.moveTo(cx, cy + 8);
        pctx.lineTo(cx + 15, cy + 20);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(cx, cy + 25);
        pctx.lineTo(cx - 12, cy + 45);
        pctx.moveTo(cx, cy + 25);
        pctx.lineTo(cx + 12, cy + 45);
        pctx.stroke();
        pctx.restore();
        // class info
        pctx.fillStyle = '#fff';
        pctx.font = 'bold 18px Arial';
        pctx.textAlign = 'center';
        pctx.fillText(cls.id, cx, cy + 70);
        pctx.font = '14px Arial';
        pctx.fillStyle = cls.color;
        pctx.fillText('‚ù§Ô∏è HP: ' + cls.hp, cx, cy + 95);
        pctx.fillText('‚¨ÜÔ∏è Jumps: ' + cls.maxJumps, cx, cy + 115);
        if (cls.ranged) {
          pctx.fillText('‚á¢ Ranged Attack (K)', cx, cy + 135)
        }
      }

      function selectClassAndRestart(i) {
        selClass = i;
        updateClassUI();
        drawClassPreview();
        restart()
      }

      function init() {
        var cls = classes[selClass];
        // load upgrades (persisted)
        loadUpgrades();
        // load settings (persisted)
        loadSettings();
        var extraHp = g.upgrades ? (g.upgrades.health || 0) : 0;
        var maxHp = cls.hp + extraHp;
        g.p = {
          x: 150,
          y: 200,
          vy: 0,
          vx: 0,
          w: 30,
          h: 50,
          jump: 0,
          gnd: 0,
          f: 0,
          right: 1,
          swing: 0,
          sf: 0,
          jl: cls.maxJumps,
          hp: maxHp,
          inv: 0,
          attackCd: 0,
          attackCdMax: 0,
          canShoot: 1,
          charging: false,
          charge: 0,
          chargeMax: 40,
          frozen: 0,
          frozenVx: 0,
          frozenVy: 0
        };
        g.plat = [{
          x: 50,
          y: 350,
          w: 200,
          h: 15
        }];
        g.coinItems = [];
        g.obs = [];
        g.en = [];
        g.projectiles = [];
        g.powerups = [];
        g.cam = 0;
        g.pgen = 1;
        g.hunters = [];
        g.spawnMul = 1;
        var last = g.plat[0];
        for (var i = 0; i < 10; i++) {
          var np = genPlat(last.x + last.w);
          g.plat.push(np);
          g.pgen++;
          var co = genCoin(np);
          if (co) g.coinItems.push(co);
          var ob = genObs(np, g.pgen);
          if (ob) g.obs.push(ob);
          var e = genEn(np, g.pgen);
          if (e) g.en.push(e);
          last = np
        }
        g.sc = 0;
        g.dist = 0;
        g.coins = 0;
        g.over = 0;
        g.start = 1;
        upSc();
        upHp();
        updateClassUI();
        updateBestDiff();
      }

      function drawStick(p, cam) {
        var x = p.x - cam,
          cx = x + 15,
          y = p.y,
          mv = Math.abs(p.vx) > .5;
        if (p.inv > 0 && Math.floor(p.inv / 5) % 2 == 0) return;
        ctx.save();
        ctx.globalAlpha = 1.0;
        var cls = classes[selClass];
        ctx.strokeStyle = p.inv > 0 ? '#fca5a5' : cls.color;
        ctx.shadowColor = cls.color;
        ctx.shadowBlur = 4;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // head with gradient
        var grad = ctx.createRadialGradient(cx, y + 10, 2, cx, y + 10, 10);
        grad.addColorStop(0, cls.color);
        grad.addColorStop(1, 'rgba(96,165,250,0.6)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, y + 10, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(cx, y + 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        // body
        ctx.beginPath();
        ctx.moveTo(cx, y + 20);
        ctx.lineTo(cx, y + 38);
        ctx.stroke();
        var as = mv ? p.f * .3 : 0,
          ls = Math.sin(as) * 8;
        // legs
        ctx.beginPath();
        ctx.moveTo(cx, y + 38);
        ctx.lineTo(cx + (p.gnd ? ls : -4), y + 50);
        ctx.moveTo(cx, y + 38);
        ctx.lineTo(cx + (p.gnd ? -ls : 4), y + 50);
        ctx.stroke();
        var sd = p.right ? 1 : -1;
        if (p.swing) {
          var sa = (p.sf / 15) * Math.PI - Math.PI / 4,
            aex = cx + Math.cos(sa) * 12 * sd,
            aey = y + 25 + Math.sin(sa) * 12;
          ctx.beginPath();
          ctx.moveTo(cx, y + 25);
          ctx.lineTo(aex, aey);
          ctx.stroke();
          var sl = 32,
            sex = aex + Math.cos(sa) * sl * sd,
            sey = aey + Math.sin(sa) * sl;
          ctx.shadowColor = '#fbbf24';
          ctx.shadowBlur = 6;
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.strokeStyle = '#ffe082';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(aex, aey);
          ctx.lineTo(sex, sey);
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else {
          // basic forearm
          ctx.beginPath();
          ctx.moveTo(cx, y + 25);
          ctx.lineTo(cx + 8 * sd, y + 30);
          ctx.stroke();
          var handx = cx + 8 * sd,
            handy = y + 30;
          if (cls.ranged) {
            // draw a simple bow in the hand
            ctx.save();
            ctx.strokeStyle = '#8b5a2b';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            if (sd > 0) {
              // bow limb: bulge AWAY from the player when facing right (convex outward)
              ctx.moveTo(handx - 2, handy - 12);
              ctx.quadraticCurveTo(handx + 18, handy, handx - 2, handy + 12);
            } else {
              // facing left: bow limb bulges AWAY from the player (convex outward)
              ctx.moveTo(handx + 2, handy - 12);
              ctx.quadraticCurveTo(handx - 18, handy, handx + 2, handy + 12);
            }
            ctx.stroke();
            // bow string with dynamic pull (use charge when holding)
            var pull = 0;
            if (p.charging && p.chargeMax) pull = p.charge / p.chargeMax; // 0..1 while holding
            var strOff = Math.round(pull * 12); // how far the string is offset
            ctx.strokeStyle = 'rgba(255,255,255,0.95)';
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            // align string endpoints to bow curve endpoints for correct placement
            if (sd > 0) {
              // string endpoints (top -> bottom)
              var bx1x = handx - 2,
                bx1y = handy - 12;
              var bx2x = handx - 2,
                bx2y = handy + 12;
              ctx.moveTo(bx1x, bx1y);
              if (strOff === 0) {
                // straight string when not pulled
                ctx.lineTo(bx2x, bx2y);
              } else {
                // when pulled, move the string control point TOWARD the player (left)
                ctx.quadraticCurveTo(handx - 18 - strOff, handy, bx2x, bx2y);
              }
            } else {
              var bx1x = handx + 2,
                bx1y = handy - 12;
              var bx2x = handx + 2,
                bx2y = handy + 12;
              ctx.moveTo(bx1x, bx1y);
              if (strOff === 0) {
                // straight string when not pulled
                ctx.lineTo(bx2x, bx2y);
              } else {
                // when pulled, move the string control point TOWARD the player (right)
                ctx.quadraticCurveTo(handx + 18 + strOff, handy, bx2x, bx2y);
              }
            }
            ctx.stroke();
            // draw nocked arrow while charging (gives visual feedback)
            if (p.charging) {
              ctx.strokeStyle = '#cbd5e1';
              ctx.lineWidth = 2;
              ctx.beginPath();
              // place the nocked arrow on the inner side (between string and player)
              // offset the arrow position by the string pull so it moves back with the string
              var pullShift = strOff; // reuse computed string offset (pixels)
              var ax = handx + (sd > 0 ? -8 - pullShift : 8 + pullShift);
              var ay = handy;
              var arrowLen = 20;
              if (sd > 0) {
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax + arrowLen, ay);
                ctx.moveTo(ax + arrowLen, ay);
                ctx.lineTo(ax + arrowLen - 4, ay - 3);
                ctx.moveTo(ax + arrowLen, ay);
                ctx.lineTo(ax + arrowLen - 4, ay + 3);
              } else {
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax - arrowLen, ay);
                ctx.moveTo(ax - arrowLen, ay);
                ctx.lineTo(ax - arrowLen + 4, ay - 3);
                ctx.moveTo(ax - arrowLen, ay);
                ctx.lineTo(ax - arrowLen + 4, ay + 3);
              }
              ctx.stroke();
            }
            ctx.restore();
          } else {
            var ha = Math.PI / 6 * sd,
              hx = cx + 8 * sd,
              hy = y + 30,
              bex = hx + Math.sin(ha) * 28,
              bey = hy + 22;
            ctx.shadowColor = 'rgba(96,165,250,0.8)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = cls.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(bex, bey);
            ctx.stroke();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(bex, bey);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        }
        // arms
        ctx.strokeStyle = p.inv > 0 ? '#fca5a5' : cls.color;
        ctx.lineWidth = 3;
        var asw = Math.sin(as) * 6;
        ctx.beginPath();
        ctx.moveTo(cx, y + 25);
        ctx.lineTo(cx + (mv ? asw : -8) * (p.right ? -1 : 1), y + 32);
        ctx.stroke();
        
        // draw web overlay if player is frozen
        if (p.frozen > 0) {
          ctx.strokeStyle = 'rgba(209, 213, 219, 0.7)';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          // web strands crossing the player
          ctx.beginPath();
          ctx.moveTo(x - 5, y);
          ctx.lineTo(x + p.w + 5, y + p.h);
          ctx.moveTo(x + p.w + 5, y);
          ctx.lineTo(x - 5, y + p.h);
          ctx.moveTo(x + p.w / 2, y - 5);
          ctx.lineTo(x + p.w / 2, y + p.h + 5);
          ctx.stroke();
          // web circle around player
          ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(cx, y + 25, 30, 0, Math.PI * 2);
          ctx.stroke();
          // frozen indicator text
          if (p.frozen > 30) { // only show for first part of freeze
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('WEBBED!', cx, y - 15);
          }
        }
        ctx.restore();
      }

      function drawPlat(p, cam) {
        var x = p.x - cam;
        var r = 8; // border radius
        // draw platform with rounded corners
        ctx.save();
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 2;
        var grad = ctx.createLinearGradient(x, p.y, x, p.y + p.h);
        grad.addColorStop(0, '#06b6d4');
        grad.addColorStop(1, '#0891b2');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(x + r, p.y);
        ctx.lineTo(x + p.w - r, p.y);
        ctx.quadraticCurveTo(x + p.w, p.y, x + p.w, p.y + r);
        ctx.lineTo(x + p.w, p.y + p.h - r);
        ctx.quadraticCurveTo(x + p.w, p.y + p.h, x + p.w - r, p.y + p.h);
        ctx.lineTo(x + r, p.y + p.h);
        ctx.quadraticCurveTo(x, p.y + p.h, x, p.y + p.h - r);
        ctx.lineTo(x, p.y + r);
        ctx.quadraticCurveTo(x, p.y, x + r, p.y);
        ctx.closePath();
        ctx.fill();
        // top highlight
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(x + 2, p.y + 1, p.w - 4, 2);
        // draw spikes if this is a trap platform (same color, hard to see)
        if (p.spikes) {
          ctx.fillStyle = '#0891b2';
          var spikeCount = Math.floor(p.w / 12);
          for (var i = 0; i < spikeCount; i++) {
            var sx = x + (p.w / spikeCount) * i + (p.w / spikeCount) / 2;
            ctx.beginPath();
            ctx.moveTo(sx - 3, p.y);
            ctx.lineTo(sx + 3, p.y);
            ctx.lineTo(sx, p.y - 4);
            ctx.closePath();
            ctx.fill();
          }
        }
        ctx.restore();
      }

      function drawCoin(co, t, cam) {
        if (co.c) return;
        var x = co.x - cam,
          pu = Math.sin(t * .005) * 2;
        ctx.save();
        ctx.translate(x, co.y);
        ctx.rotate(t * 0.003);
        // outer glow
        ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, co.r + 6, 0, Math.PI * 2);
        ctx.fill();
        // main coin with gradient
        var grad = ctx.createRadialGradient(0, -3, 0, 0, 0, co.r);
        grad.addColorStop(0, '#fcd34d');
        grad.addColorStop(0.7, '#fbbf24');
        grad.addColorStop(1, '#f59e0b');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, co.r + pu, 0, Math.PI * 2);
        ctx.fill();
        // shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(-3, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawObs(o, cam) {
        var x = o.x - cam;
        ctx.save();
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 2;
        ctx.fillStyle = '#dc2626';
        ctx.beginPath();
        ctx.moveTo(x, o.y + o.h);
        ctx.lineTo(x + o.w / 2, o.y - 2);
        ctx.lineTo(x + o.w, o.y + o.h);
        ctx.closePath();
        ctx.fill();
        // highlight on spike
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + o.w / 2 - 1, o.y);
        ctx.lineTo(x + o.w / 2 + 1, o.y);
        ctx.stroke();
        ctx.restore();
      }

      function drawEn(e, cam) {
        if (e.dead) return;
        var x = e.x - cam,
          cx = x + 12,
          y = e.y;
        ctx.save();
        var isHunter = e.type === 'hunter';
        var isArcher = e.type === 'archer';
        ctx.shadowColor = isHunter ? '#a855f7' : isArcher ? '#0ea5e9' : '#ef4444';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 1;
        // head with gradient
        var grad = ctx.createRadialGradient(cx, y + 8, 2, cx, y + 8, 8);
        if (isHunter) {
          grad.addColorStop(0, '#d946ef');
          grad.addColorStop(1, '#a855f7');
        } else if (isArcher) {
          grad.addColorStop(0, '#06b6d4');
          grad.addColorStop(1, '#0891b2');
        } else {
          grad.addColorStop(0, '#f87171');
          grad.addColorStop(1, '#dc2626');
        }
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, y + 8, 8, 0, Math.PI * 2);
        ctx.fill();
        // outline
        ctx.strokeStyle = isHunter ? '#7c3aed' : isArcher ? '#0369a1' : '#991b1b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, y + 8, 8, 0, Math.PI * 2);
        ctx.stroke();
        if (isHunter) {
          // hunter has glowing eyes
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 1, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 1, 0, Math.PI * 2);
          ctx.fill();
          // hunter has sharper limbs
          ctx.strokeStyle = '#d946ef';
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 32);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 22);
          ctx.lineTo(cx - 10, y + 28);
          ctx.moveTo(cx, y + 22);
          ctx.lineTo(cx + 10, y + 28);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 32);
          ctx.lineTo(cx - 7, y + 42);
          ctx.moveTo(cx, y + 32);
          ctx.lineTo(cx + 7, y + 42);
          ctx.stroke();
        } else if (isArcher) {
          // archer has targeting reticle eyes
          ctx.fillStyle = '#06b6d4';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#0369a1';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2.5, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2.5, 0, Math.PI * 2);
          ctx.stroke();
          // archer body
          ctx.strokeStyle = '#0ea5e9';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 30);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx - 6, y + 40);
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx + 6, y + 40);
          ctx.stroke();
          
          // bow in hand - points at player when drawing/shooting
          ctx.save();
          
          // calculate angle to player
          var px = g.p.x + g.p.w / 2 - g.cam;
          var py = g.p.y + g.p.h / 2;
          var angleToPlayer = Math.atan2(py - (y + 20), px - cx);
          
          // draw bow-holding arm first
          var bowArmLen = 12;
          var bowHandX = cx + Math.cos(angleToPlayer) * bowArmLen;
          var bowHandY = y + 20 + Math.sin(angleToPlayer) * bowArmLen;
          
          ctx.strokeStyle = '#0ea5e9';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 20);
          ctx.lineTo(bowHandX, bowHandY);
          ctx.stroke();
          
          // position bow at hand
          ctx.translate(bowHandX, bowHandY);
          ctx.rotate(angleToPlayer);
          
          // calculate draw amount (0 to 1)
          var drawAmount = 0;
          if (e._drawing && e._drawProgress) {
            drawAmount = Math.min(1, e._drawProgress / e._drawDuration);
          }
          
          // bow limb with bending based on draw
          var bendAmount = drawAmount * 5; // pixels to bend
          ctx.strokeStyle = '#8b4513';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          
          // bow curves outward when drawn
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.quadraticCurveTo(8 + bendAmount, 0, 0, 8);
          ctx.stroke();
          
          // bow string - pulled back when drawing
          var stringPull = drawAmount * 12; // how far back string is pulled
          ctx.strokeStyle = '#d4d4d8';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(0, -8);
          if (drawAmount > 0) {
            // string is pulled back in a curve
            ctx.quadraticCurveTo(-stringPull, 0, 0, 8);
          } else {
            // straight string when not drawn
            ctx.lineTo(0, 8);
          }
          ctx.stroke();
          
          // draw nocked arrow when drawing
          if (drawAmount > 0) {
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 2;
            var arrowX = -stringPull;
            ctx.beginPath();
            ctx.moveTo(arrowX, 0);
            ctx.lineTo(arrowX + 15, 0);
            ctx.stroke();
            // arrow head
            ctx.beginPath();
            ctx.moveTo(arrowX + 15, 0);
            ctx.lineTo(arrowX + 12, -2);
            ctx.moveTo(arrowX + 15, 0);
            ctx.lineTo(arrowX + 12, 2);
            ctx.stroke();
          }
          
          ctx.restore();
          
          // off-hand arm (pulling string back)
          if (drawAmount > 0) {
            var pullBackDist = drawAmount * 12;
            var stringHandX = bowHandX + Math.cos(angleToPlayer) * (-pullBackDist);
            var stringHandY = bowHandY + Math.sin(angleToPlayer) * (-pullBackDist);
            
            ctx.strokeStyle = '#0ea5e9';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(cx, y + 20);
            ctx.lineTo(stringHandX, stringHandY);
            ctx.stroke();
          } else {
            // idle off-hand
            var armAngle = angleToPlayer - Math.PI / 6;
            ctx.strokeStyle = '#0ea5e9';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(cx, y + 20);
            ctx.lineTo(cx + Math.cos(armAngle) * 10, y + 20 + Math.sin(armAngle) * 10);
            ctx.stroke();
          }
        } else if (e.type === 'spider') {
          // spider on ceiling - black/dark realistic spider like the jpeg
          var bodyCenterY = y + 18;
          ctx.shadowColor = 'rgba(0,0,0,0.5)';
          ctx.shadowBlur = 10;
          
          // spider legs (8 legs, 4 on each side) - long thin dark legs
          ctx.strokeStyle = '#1f2937';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          var legPairs = [
            [-85, 22], [-60, 24], [-105, 20], [-125, 18],  // left side
            [85, 22], [60, 24], [105, 20], [125, 18]        // right side
          ];
          for (var li = 0; li < 8; li++) {
            var legAngle = (legPairs[li][0] * Math.PI / 180) + Math.sin(Date.now() * 0.008 + li) * 0.12;
            var legLen = legPairs[li][1];
            // two-segment leg for more realistic look
            var midLen = legLen * 0.55;
            var endLen = legLen * 0.45;
            
            ctx.beginPath();
            ctx.moveTo(cx, bodyCenterY);
            var midX = cx + Math.cos(legAngle) * midLen;
            var midY = bodyCenterY + Math.sin(legAngle) * midLen;
            ctx.lineTo(midX, midY);
            
            // second segment bends down slightly
            var endAngle = legAngle + (li < 4 ? -0.5 : 0.5);
            var endX = midX + Math.cos(endAngle) * endLen;
            var endY = midY + Math.sin(endAngle) * endLen;
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // leg joints (thicker at joints)
            ctx.fillStyle = '#374151';
            ctx.beginPath();
            ctx.arc(midX, midY, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // spider body - round and dark black/gray
          var bodyGrad = ctx.createRadialGradient(cx - 3, bodyCenterY - 3, 2, cx, bodyCenterY, 16);
          bodyGrad.addColorStop(0, '#4b5563');
          bodyGrad.addColorStop(0.7, '#1f2937');
          bodyGrad.addColorStop(1, '#111827');
          ctx.fillStyle = bodyGrad;
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cx, bodyCenterY, 16, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // smaller head section in front
          var headGrad = ctx.createRadialGradient(cx - 1, bodyCenterY - 12, 1, cx, bodyCenterY - 10, 6);
          headGrad.addColorStop(0, '#4b5563');
          headGrad.addColorStop(1, '#1f2937');
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(cx, bodyCenterY - 10, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1.5;
          ctx.stroke();
          
          // spider eyes - small red/orange glowing dots
          ctx.shadowBlur = 6;
          ctx.shadowColor = '#ef4444';
          ctx.fillStyle = '#ef4444';
          // two main front eyes
          ctx.beginPath();
          ctx.arc(cx - 3, bodyCenterY - 12, 1.5, 0, Math.PI * 2);
          ctx.arc(cx + 3, bodyCenterY - 12, 1.5, 0, Math.PI * 2);
          ctx.fill();
          
          // body texture/markings
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#6b7280';
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.arc(cx, bodyCenterY, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1;
          
          ctx.shadowBlur = 0;
        } else {
          // regular enemy eyes
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 2, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx - 3, y + 6, 1, 0, Math.PI * 2);
          ctx.arc(cx + 3, y + 6, 1, 0, Math.PI * 2);
          ctx.fill();
          // body and limbs
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 2.5;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(cx, y + 16);
          ctx.lineTo(cx, y + 30);
          ctx.stroke();
          // legs
          ctx.beginPath();
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx - 6, y + 40);
          ctx.moveTo(cx, y + 30);
          ctx.lineTo(cx + 6, y + 40);
          ctx.stroke();
          
          // weapon rendering and attack animations
          var tier = e.weaponTier || 0;
          var sd = e.vx > 0 ? 1 : -1;
          
          if (e.attacking) {
            var progress = e.attackFrame / 15;
            var attackAngle = 0;
            
            if (tier === 0) {
              // unarmed - punching animation
              attackAngle = Math.sin(progress * Math.PI) * Math.PI / 3;
              var armLen = 12;
              var armX = cx + Math.cos(attackAngle) * armLen * sd;
              var armY = y + 22 + Math.sin(attackAngle) * armLen;
              
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(cx, y + 20);
              ctx.lineTo(armX, armY);
              ctx.stroke();
              
              // fist
              ctx.fillStyle = '#b91c1c';
              ctx.beginPath();
              ctx.arc(armX, armY, 4, 0, Math.PI * 2);
              ctx.fill();
              
              // back arm
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.moveTo(cx, y + 20);
              ctx.lineTo(cx - 8 * sd, y + 26);
              ctx.stroke();
            } else if (tier === 1) {
              // knife jab/thrust animation (forward motion)
              var thrust = progress < 0.5 ? progress * 2 : (1 - (progress - 0.5) * 2); // 0 to 1 to 0
              var extendDist = thrust * 10; // extend only 10 pixels max for more natural look
              var armX = cx + (8 + extendDist) * sd;
              var armY = y + 22;
              
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.moveTo(cx, y + 20);
              ctx.lineTo(armX, armY);
              ctx.stroke();
              
              // knife blade extending forward
              var bladeLen = 15;
              var bladeX = armX + bladeLen * sd;
              var bladeY = armY;
              
              ctx.strokeStyle = '#94a3b8';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(armX, armY);
              ctx.lineTo(bladeX, bladeY);
              ctx.stroke();
              
              // blade tip
              ctx.strokeStyle = '#cbd5e1';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(bladeX - 3 * sd, bladeY);
              ctx.lineTo(bladeX, bladeY);
              ctx.stroke();
              
              // back arm
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.moveTo(cx, y + 20);
              ctx.lineTo(cx - 8 * sd, y + 26);
              ctx.stroke();
            } else if (tier === 2) {
              // sword attack animation (like player)
              attackAngle = (e.attackFrame / 15) * Math.PI - Math.PI / 4;
              var armLen = 12;
              var armX = cx + Math.cos(attackAngle) * armLen * sd;
              var armY = y + 25 + Math.sin(attackAngle) * armLen;
              
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 2.5;
              ctx.beginPath();
              ctx.moveTo(cx, y + 25);
              ctx.lineTo(armX, armY);
              ctx.stroke();
              
              // sword
              var swordLen = 28;
              var swordX = armX + Math.cos(attackAngle) * swordLen * sd;
              var swordY = armY + Math.sin(attackAngle) * swordLen;
              
              ctx.shadowColor = '#fbbf24';
              ctx.shadowBlur = 6;
              ctx.strokeStyle = '#fbbf24';
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(armX, armY);
              ctx.lineTo(swordX, swordY);
              ctx.stroke();
              ctx.strokeStyle = '#f59e0b';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(armX, armY);
              ctx.lineTo(swordX, swordY);
              ctx.stroke();
              ctx.shadowBlur = 0;
            }
          } else {
            // idle state - draw normal arms
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(cx, y + 20);
            ctx.lineTo(cx - 8, y + 26);
            ctx.moveTo(cx, y + 20);
            ctx.lineTo(cx + 8, y + 26);
            ctx.stroke();
            
            // idle weapon display
            if (tier === 1) {
              // small knife at side
              var knifeX = cx + 10 * sd;
              var knifeY = y + 28;
              ctx.strokeStyle = '#94a3b8';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(knifeX, knifeY);
              ctx.lineTo(knifeX + 8 * sd, knifeY + 6);
              ctx.stroke();
            } else if (tier === 2) {
              // sword at side
              var swordX = cx + 8 * sd;
              var swordY = y + 26;
              ctx.strokeStyle = '#fbbf24';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(swordX, swordY);
              ctx.lineTo(swordX + 6 * sd, swordY + 20);
              ctx.stroke();
            }
          }
        }
        // hp indicator
        if (e.hp > 0) {
          ctx.fillStyle = '#fef08a';
          ctx.font = 'bold 11px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(e.hp, cx, y - 8)
        }
        ctx.restore();
      }
      // Platform path utilities moved to ai_hunter.js for modularity
      // (findPlatformIndexAtX, platformGap, canJump, findPlatformPath, findHunterPath)
      // The functions are loaded from ai_hunter.js which is included before this script.
      // Fallback implementations if module fails to load
      if (typeof findPlatformIndexAtX === 'undefined') {
        window.findPlatformIndexAtX = function(x, w) {
          var cx = x + (w || 0) / 2;
          for (var i = 0; i < (window.g && g.plat ? g.plat.length : 0); i++) {
            var pl = g.plat[i];
            if (cx >= pl.x && cx <= pl.x + pl.w) return i;
          }
          return -1;
        };
      }
      if (typeof canJump === 'undefined') {
        window.canJump = function(from, to) {
          if (!from || !to) return false;
          var gap = (to.x > from.x) ? (to.x - (from.x + from.w)) : (from.x - (to.x + to.w));
          if (gap > 240) return false;
          if (to.y - from.y > 160) return false;
          return true;
        };
      }
      if (typeof findPlatformPath === 'undefined') {
        window.findPlatformPath = function(startIdx, targetIdx) {
          if (!window.g || !g.plat || startIdx === -1 || targetIdx === -1) return null;
          if (startIdx === targetIdx) return [startIdx];
          // Simple BFS if A* not available
          var visited = {}; visited[startIdx] = true;
          var queue = [[startIdx]]; 
          while (queue.length) {
            var path = queue.shift();
            var cur = path[path.length - 1];
            if (cur === targetIdx) return path;
            var curPl = g.plat[cur];
            for (var j = 0; j < g.plat.length; j++) {
              if (j === cur || visited[j]) continue;
              if (canJump(curPl, g.plat[j]) || canJump(g.plat[j], curPl)) {
                visited[j] = true;
                queue.push(path.concat([j]));
              }
            }
          }
          return null;
        };
      }

      function coll(r1, r2) {
        return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y
      }

      function getSwHit(p) {
        var sd = p.right ? 1 : -1,
          cx = p.x + 15;
        return {
          x: cx + (sd > 0 ? 10 : -40),
          y: p.y + 10,
          w: 40,
          h: 35
        }
      }

      function findClosestTarget(p, cam) {
        var closest = null,
          minDist = 300; // max targeting range
        for (var i = 0; i < g.en.length; i++) {
          var e = g.en[i];
          if (e.dead) continue;
          var ex = e.x - cam,
            ey = e.y;
          if (ex < 0 || ex > W) continue; // only target if within frame
          var dx = ex - (p.x - cam + 15),
            dy = ey - (p.y + 20);
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            closest = e;
          }
        }
        return closest;
      }

      function upSc() {
        document.getElementById('score').textContent = g.sc;
        g.coins = Math.floor(g.sc * 0.1);
        document.getElementById('coins').textContent = g.coins;
        document.getElementById('high').textContent = g.hi;
        document.getElementById('highScoreDisplay2').textContent = g.hi;
        updateUpgradeUI()
      }

      function upHp() {
        var maxHp = classes[selClass].hp + (g.upgrades ? (g.upgrades.health || 0) : 0);
        var percentage = Math.max(0, Math.min(100, (g.p.hp / maxHp) * 100));
        document.getElementById('healthBarFill').style.width = percentage + '%';
      }

      function updateBestDiff() {
        var el = document.getElementById('bestDiffBar');
        if (!el) return;
        var best = g.bestDist || 0;
        var diff = g.dist - best;
        var sign = diff > 0 ? '+' : '';
        el.textContent = 'Distance to best: ' + sign + diff;
        // color positive green, negative/red when behind, neutral gray
        if (diff > 0) el.style.background = 'rgba(4,120,87,0.9)', el.style.color = '#bbf7d0';
        else if (diff < 0) el.style.background = 'rgba(83,37,28,0.9)', el.style.color = '#fecaca';
        else el.style.background = 'rgba(2,6,23,0.7)', el.style.color = '#cbd5e1';
      }
      // Upgrades: load/save and UI
      function loadUpgrades() {
        g.upgrades = {
          damage: Number(getCookie('upg_damage') || 0),
          speed: Number(getCookie('upg_speed') || 0),
          health: Number(getCookie('upg_health') || 0)
        };
      }

      function saveUpgrade(key) {
        setCookie('upg_' + key, g.upgrades[key] || 0);
      }

      function getUpgradeCost(key) {
        var base = {
          damage: 200,
          speed: 150,
          health: 120
        } [key] || 100;
        var lvl = g.upgrades[key] || 0;
        return Math.max(50, Math.round(base * Math.pow(2, lvl)));
      }

      function updateUpgradeUI() {
        if (!g.upgrades) loadUpgrades();
        document.getElementById('upgDamageLevel').textContent = g.upgrades.damage;
        document.getElementById('upgSpeedLevel').textContent = g.upgrades.speed;
        document.getElementById('upgHealthLevel').textContent = g.upgrades.health;
        document.getElementById('upgDamageCost').textContent = getUpgradeCost('damage');
        document.getElementById('upgSpeedCost').textContent = getUpgradeCost('speed');
        document.getElementById('upgHealthCost').textContent = getUpgradeCost('health');
        // enable/disable buttons based on available currency
        var sd = g.coins >= getUpgradeCost('damage');
        var ss = g.coins >= getUpgradeCost('speed');
        var sh = g.coins >= getUpgradeCost('health');
        document.getElementById('buyDamage').disabled = !sd;
        document.getElementById('buySpeed').disabled = !ss;
        document.getElementById('buyHealth').disabled = !sh;
      }

      // Settings: debug toggles and persistence
      function loadSettings() {
        var raw = document.cookie.split(';').map(function(s){return s.trim();}).find(function(s){return s.indexOf('dbg_hunter=')===0});
        if (raw === undefined) g.showHunterDebug = true; else g.showHunterDebug = Number(raw.split('=')[1]) === 1;
        var el = document.getElementById('debugHuntersCheckbox'); if (el) el.checked = g.showHunterDebug;
      }
      function toggleHunterDebug(checked) {
        g.showHunterDebug = !!checked; setCookie('dbg_hunter', g.showHunterDebug ? 1 : 0);
      }

      // toggle debug drawing for hunters
      function toggleHunterDebug(checked) {
        g.debugHunterPaths = !!checked;
        setCookie('debugHunters', checked ? 1 : 0);
      }

      function goToUpgrades() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        document.getElementById('upgrades').classList.remove('hidden');
        updateUpgradeUI();
      }

      function closeUpgrades() {
        document.getElementById('upgrades').classList.add('hidden');
        document.getElementById('mainMenu').classList.remove('hidden');
      }

      function buyUpgrade(key) {
        var cost = getUpgradeCost(key);
        if (g.coins < cost) return;
        g.coins -= cost; // spend coins
        g.upgrades[key] = (g.upgrades[key] || 0) + 1;
        saveUpgrade(key);
        updateUpgradeUI();
        // reapply upgrades to player if inited
        if (g.p) {
          if (key === 'health') {
            g.p.hp += 1;
            upHp();
          }
        }
      }

      function endGame() {
        g.over = 1;
        if (g.sc > g.hi) {
          g.hi = g.sc;
          setCookie('highScore', g.hi)
        }
        // persist best distance
        if (g.dist > (g.bestDist || 0)) {
          g.bestDist = g.dist;
          setCookie('bestDist', g.bestDist)
        }
        document.getElementById('final').textContent = g.sc;
        document.getElementById('best').textContent = g.hi;
        document.getElementById('over').classList.remove('hidden');
        if (anim) cancelAnimationFrame(anim);
        gameOverSound();
        updateBestDiff();
      }

      function loop(t) {
        if (g.over || !g.start) return;
        try {
          anim = requestAnimationFrame(loop);
          
          // Update navigation grid periodically (every 10 frames)
          if (typeof updateNavigationGrid === 'function') {
            if (!g._gridUpdateCounter) g._gridUpdateCounter = 0;
            g._gridUpdateCounter++;
            if (g._gridUpdateCounter >= 10) {
              updateNavigationGrid(g.plat, g.cam, W, H);
              g._gridUpdateCounter = 0;
            }
          }
          
          // enhanced background with gradient
          var bgGrad = ctx.createLinearGradient(0, 0, 0, H);
          bgGrad.addColorStop(0, '#0f172a');
          bgGrad.addColorStop(1, '#1e293b');
          ctx.fillStyle = bgGrad;
          ctx.fillRect(0, 0, W, H);
          var p = g.p;
          var cls = classes[selClass];
        var speedMul = 1 + ((g.upgrades && g.upgrades.speed) ? (0.08 * g.upgrades.speed) : 0);
        // apply speed boost if active
        if (p._speedBoost && p._speedBoost > 0) {
          p._speedBoost--;
          speedMul *= 1.4; // 40% faster
        }
        // handle frozen state
        if (p.frozen > 0) {
          p.frozen--;
          // frozen - can't control movement but still affected by gravity
          p.vx = 0;
        } else {
          var baseSpeed = 6 * speedMul;
          if (g.k.left) {
            p.vx = -baseSpeed;
            p.right = 0
          } else if (g.k.right) {
            p.vx = baseSpeed;
            p.right = 1
          } else p.vx *= .8
        }
        // jump handling uses class max jumps (can't jump when frozen)
        if (g.k.up && p.jl > 0 && p.frozen <= 0) {
          p.vy = -14;
          p.jump = 1;
          p.gnd = 0;
          p.jl--;
          g.k.up = 0;
          jumpSound()
        }
        // ranged attack (Archer) with auto-targeting and hold-to-draw (can't attack when frozen)
        if (cls.ranged && p.frozen <= 0) {
          g.targetLock = findClosestTarget(p, g.cam);
          // start charging on attack press (if weapon is ready)
          if (g.k.attack && p.canShoot && !p.charging) {
            p.charging = true;
            p.charge = 0;
          }
          // accumulate charge while holding
          if (p.charging) {
            p.charge++;
            if (p.charge > p.chargeMax) p.charge = p.chargeMax;
          }
          // release: when attack key lifted and we were charging
          if (!g.k.attack && p.charging) {
            var power = p.charge / p.chargeMax; // 0..1
            var tgtX = g.targetLock ? g.targetLock.x - g.cam : p.x + (p.right ? p.w : -8);
            var tgtY = g.targetLock ? g.targetLock.y : p.y;
            var angle = Math.atan2(tgtY - (p.y + 20), tgtX - (p.x - g.cam + 15));
            var speed = 6 + power * 14; // range ~6 - 20
            var vx = Math.cos(angle) * speed,
              vy = Math.sin(angle) * speed;
            var pr = {
              x: p.x + (p.right ? p.w : -8),
              y: p.y + 20,
              vx: vx,
              vy: vy,
              w: 10,
              h: 4,
              life: 80,
              type: 'arrow',
              rot: angle,
              power: power
            };
            g.projectiles.push(pr);
            shootSound();
            p.canShoot = 0;
            // cooldown scales with power (higher power -> longer cooldown)
            p.attackCd = 18 + Math.round(36 * power); // 18..54
            p.attackCdMax = p.attackCd;
            p.charging = false;
            p.charge = 0;
            p.right = vx > 0 ? 1 : 0;
          }
        }
        if (p.attackCd > 0) {
          p.attackCd--;
          if (p.attackCd == 0) p.canShoot = 1
        }
        if (g.k.swing && !p.swing && p.frozen <= 0) {
          p.swing = 1;
          p.sf = 0;
          attackSound()
        }
        if (p.swing) {
          p.sf++;
          if (p.sf >= 15) {
            p.swing = 0;
            p.sf = 0
          }
        }
        p.vy += .6;
        p.y += p.vy;
        p.x += p.vx;
        if (p.x < g.cam + 50) p.x = g.cam + 50;
        var tc = p.x - W * 0.4; // Center player at 40% from left (more centered)
        if (tc > g.cam) g.cam = tc;
        if (Math.abs(p.vx) > .5) p.f += .5;
        if (p.inv > 0) p.inv--;
        p.gnd = 0;
        for (var i = 0; i < g.plat.length; i++) {
          var pl = g.plat[i];
          if (p.vy >= 0 && p.x + p.w > pl.x && p.x < pl.x + pl.w && p.y + p.h >= pl.y && p.y + p.h <= pl.y + pl.h + 15) {
            // check if platform has spikes
            if (pl.spikes) {
              p.hp = 0;
              endGame();
            } else {
              p.y = pl.y - p.h;
              p.vy = 0;
              p.gnd = 1;
              p.jump = 0;
              p.jl = cls.maxJumps
            }
          }
        }
        // arrow collision - player can jump on arrows
        for (var i = 0; i < g.projectiles.length; i++) {
          var pr = g.projectiles[i];
          if ((pr.type === 'arrow' || pr.type === 'enemy_arrow') && p.vy >= 0) {
            // arrow collision box (larger than visual for easier jumping)
            var arrowCollision = {
              x: pr.x - 10,
              y: pr.y - 5,
              w: 20,
              h: 15
            };
            var playerBox = {
              x: p.x,
              y: p.y + p.h - 2,
              w: p.w,
              h: 4
            };
            if (coll(playerBox, arrowCollision)) {
              p.y = pr.y - p.h - 5;
              p.vy = 0;
              p.gnd = 1;
              p.jump = 0;
              p.jl = cls.maxJumps;
            }
          }
        }
        // enemies
        for (var i = 0; i < g.en.length; i++) {
          var e = g.en[i];
          if (e.dead) continue;
          // hunter behavior: Minecraft-style platform pathfinding
          if (e.type === 'hunter') {
            var speed = e.speed || 2.5;
            var targetPlatIdx = findPlatformIndexAtX(p.x, p.w);
            var currentPlatIdx = findPlatformIndexAtX(e.x, e.w);
            
            // Don't move if not on a valid platform (prevents void walking)
            if (currentPlatIdx === -1) {
              e.vx = 0;
              e.vy = (e.vy || 0) + 0.6;
              e.y += e.vy;
              e.x += e.vx;
            } else {
              // Stuck detection (like Minecraft mobs)
              if (Math.abs(e.x - (e._lastX || 0)) < 0.5) {
                e._stuckTimer = (e._stuckTimer || 0) + 1;
              } else {
                e._stuckTimer = 0;
              }
              e._lastX = e.x;
              
              // Recalculate path periodically or when stuck
              e._recalcTimer = (e._recalcTimer || 0) - 1;
              if (e._recalcTimer <= 0 || e._stuckTimer > 30 || !e._platformPath) {
                e._platformPath = findPlatformPathAStar(currentPlatIdx, targetPlatIdx, g.plat);
                e._pathIndex = 0;
                e._recalcTimer = 45; // recalc every 0.75 seconds
                e._stuckTimer = 0;
              }
            
              // Check distance to player for attack
              var distToPlayer = Math.abs((p.x + p.w/2) - (e.x + e.w/2));
              var vertDistToPlayer = Math.abs(p.y - e.y);
              
              // Attack if close enough (hunters use unarmed attacks)
              if (distToPlayer < 40 && vertDistToPlayer < 50 && e.attackCooldown <= 0) {
                e.attacking = 1;
                e.attackFrame = 0;
                e.attackCooldown = 35;
                e.vx = 0; // stop while attacking
              }
              
              // Follow calculated path (only if not attacking)
              if (!e.attacking && e._platformPath && e._platformPath.length > 1) {
                var nextPlatIdx = e._platformPath[Math.min(e._pathIndex + 1, e._platformPath.length - 1)];
                var nextPlat = g.plat[nextPlatIdx];
                var currentPlat = g.plat[currentPlatIdx];
                
                if (nextPlat) {
                  var targetX = nextPlat.x + nextPlat.w / 2;
                  var dx = targetX - (e.x + e.w / 2);
                  var dist = Math.abs(dx);
                  
                  // Check if we need to jump to reach next platform
                  var needsJump = false;
                  if (currentPlat && nextPlat) {
                    var gap = nextPlat.x > currentPlat.x ?
                      (nextPlat.x - (currentPlat.x + currentPlat.w)) :
                      (currentPlat.x - (nextPlat.x + nextPlat.w));
                    var heightDiff = currentPlat.y - nextPlat.y;
                    
                    // Jump if there's a gap or platform is higher
                    needsJump = gap > 10 || heightDiff > 5;
                  }
                  
                  // Safety check: don't walk off platform edge without jumping
                  var platformEdgeLeft = currentPlat.x;
                  var platformEdgeRight = currentPlat.x + currentPlat.w;
                  var willWalkOff = false;
                  if (dx > 0) { // moving right
                    willWalkOff = (e.x + e.w + speed * 2) > platformEdgeRight && !needsJump;
                  } else if (dx < 0) { // moving left
                    willWalkOff = (e.x - speed * 2) < platformEdgeLeft && !needsJump;
                  }
                  
                  // Move toward target only if safe
                  if (!willWalkOff) {
                    if (dist > 20) {
                      e.vx = Math.sign(dx) * speed;
                    } else {
                      e.vx = Math.sign(dx) * speed * 0.5;
                    }
                  } else {
                    e.vx = 0; // stop at edge
                  }
                  
                  // Execute jump when needed and on ground
                  if (needsJump && e.gnd && e.jl > 0) {
                    e.vy = -13;
                    e.gnd = 0;
                    e.jl--;
                  }
                  
                  // Advance to next waypoint when close
                  if (dist < 30 && Math.abs(e.y - nextPlat.y) < 20) {
                    e._pathIndex++;
                    if (e._pathIndex >= e._platformPath.length - 1) {
                      // Reached end of path, recalculate
                      e._recalcTimer = 0;
                    }
                  }
                }
              } else if (!e.attacking) {
                // No path found - try direct approach if close
                var dx = p.x - e.x;
                if (distToPlayer < 150 && vertDistToPlayer < 50) {
                  if (Math.abs(dx) > 20) {
                    e.vx = Math.sign(dx) * speed * 0.5;
                  }
                } else {
                  e.vx = 0;
                }
              }
              
              // Handle attack animation and hitbox
              if (e.attacking) {
                e.attackFrame++;
                e.vx = 0; // don't move during attack
                
                // Unarmed punch hitbox (frame 5-10)
                if (e.attackFrame >= 5 && e.attackFrame <= 10) {
                  var punchReach = 25;
                  var punchX = e.x + (e.vx < 0 ? -punchReach : e.w);
                  var punchY = e.y + 10;
                  var punchSize = 10;
                  
                  // Check collision with player
                  if (punchX < p.x + p.w && punchX + punchSize > p.x &&
                      punchY < p.y + p.h && punchY + punchSize > p.y) {
                    if (!p.shd && !p.invuln) {
                      p.hp -= 1;
                      p.invuln = 30;
                      // Knockback
                      var kbDir = Math.sign((p.x + p.w/2) - (e.x + e.w/2));
                      p.vx = kbDir * 8;
                      p.vy = -8;
                    }
                  }
                }
                
                if (e.attackFrame >= 20) {
                  e.attacking = 0;
                  e.attackFrame = 0;
                }
              }
              
              // Cooldown tick
              if (e.attackCooldown > 0) e.attackCooldown--;
              
              // Apply physics
              e.vy = (e.vy || 0) + 0.6;
              e.y += e.vy;
              e.x += e.vx;
            }
            
            // Landing detection and reset jumps
            e.gnd = 0;
            for (var j = 0; j < g.plat.length; j++) {
              var pl = g.plat[j];
              if (e.vy >= 0 && e.x + e.w > pl.x && e.x < pl.x + pl.w &&
                  e.y + e.h >= pl.y && e.y + e.h <= pl.y + pl.h + 15) {
                if (pl.spikes) {
                  e.dead = 1;
                } else {
                  e.y = pl.y - e.h;
                  e.vy = 0;
                  e.gnd = 1;
                  e.jl = e.maxJumps || 2;
                }
              }
            }
          } else if (e.type === 'archer') {
            // archer enemy: patrols and shoots at player
            var speed = e.speed || 1.5;
            var dx = p.x - e.x;
            
            // simple patrol
            e.x += e.vx;
            if (e.x <= e.pl || e.x + e.w >= e.pr) e.vx *= -1;
            
            // keep aligned to platform
            var plIdx = findPlatformIndexAtX(e.x, e.w);
            if (plIdx !== -1) {
              e.y = g.plat[plIdx].y - e.h;
              e.gnd = 1;
            }
            
            // shooting behavior: draw bow then fire at player periodically
            if (!e._drawing) {
              e._shootCooldown--;
              if (e._shootCooldown <= 0 && Math.abs(dx) < 500) {
                // start drawing bow
                e._drawing = true;
                e._drawProgress = 0;
                e._drawDuration = 30; // 0.5 seconds to draw
              }
            } else {
              // drawing bow
              e._drawProgress++;
              e.vx *= 0.95; // slow down while drawing
              
              if (e._drawProgress >= e._drawDuration) {
                // release arrow
                var ex = e.x + e.w / 2;
                var ey = e.y + e.h / 2;
                var py = p.y + 20;
                var angle = Math.atan2(py - ey, (p.x - g.cam + 15) - (ex - g.cam));
                var arrowSpeed = 8;
                var vx = Math.cos(angle) * arrowSpeed;
                var vy = Math.sin(angle) * arrowSpeed;
                
                var arrow = {
                  x: ex,
                  y: ey,
                  vx: vx,
                  vy: vy,
                  w: 10,
                  h: 4,
                  life: 100,
                  type: 'enemy_arrow',
                  rot: angle,
                  power: 0.5
                };
                g.projectiles.push(arrow);
                e._drawing = false;
                e._drawProgress = 0;
                e._shootCooldown = 60 + Math.floor(Math.random() * 40); // shoot every ~1-1.7 seconds
              }
            }
            
            // apply physics
            e.vy = (e.vy || 0) + 0.6;
            e.y += e.vy;
            
            // landing detection
            e.gnd = 0;
            for (var j = 0; j < g.plat.length; j++) {
              var pl = g.plat[j];
              if (e.vy >= 0 && e.x + e.w > pl.x && e.x < pl.x + pl.w && e.y + e.h >= pl.y && e.y + e.h <= pl.y + pl.h + 15) {
                if (pl.spikes) {
                  e.dead = 1;
                } else {
                  e.y = pl.y - e.h; e.vy = 0; e.gnd = 1;
                }
              }
            }
          } else if (e.type === 'spider') {
            // spider crawls on ceiling and can swing or shoot webs
            var speed = e.speed || 1.2;
            
            if (!e._swinging) {
              // track and follow player position
              var dx = p.x - e.x;
              if (Math.abs(dx) > 30) {
                e.vx = Math.sign(dx) * speed;
              } else {
                e.vx *= 0.9; // slow down when close
              }
              e.x += e.vx;
              
              // keep on ceiling at fixed height above platform
              var plIdx = findPlatformIndexAtX(e.x, e.w);
              if (plIdx !== -1) {
                var platform = g.plat[plIdx];
                e.y = platform.y - platform.h - 120; // stay high above platform (out of reach)
                e.onCeiling = true;
              }
              
              // stay within platform bounds (but allow some overhang)
              if (e.x < e.pl - 20) e.x = e.pl - 20;
              if (e.x + e.w > e.pr + 20) e.x = e.pr + 20 - e.w;
              
              // decide between shooting web or swinging
              e._shootCooldown--;
              if (e._shootCooldown <= 0 && Math.abs(p.x - e.x) < 400) {
                var ex = e.x + e.w / 2;
                var ey = e.y + e.h;
                
                // alternate between shoot and swing attacks
                if (e._attackMode === 'shoot') {
                  // shoot web projectile at player
                  var py = p.y + 20;
                  var angle = Math.atan2(py - ey, (p.x + 15) - ex);
                  var webSpeed = 6;
                  var vx = Math.cos(angle) * webSpeed;
                  var vy = Math.sin(angle) * webSpeed;
                  
                  var web = {
                    x: ex,
                    y: ey,
                    vx: vx,
                    vy: vy,
                    w: 12,
                    h: 12,
                    life: 150,
                    type: 'web'
                  };
                  g.projectiles.push(web);
                  e._attackMode = 'swing'; // next attack will be swing
                  e._shootCooldown = 90 + Math.floor(Math.random() * 60);
                } else {
                  // start swing attack if player is below and in range
                  if (p.y > e.y && Math.abs(p.x - e.x) < 300) {
                    // calculate distance to player to determine web length
                    var distX = (p.x + p.w / 2) - ex;
                    var distY = (p.y + p.h / 2) - ey;
                    var distToPlayer = Math.sqrt(distX * distX + distY * distY);
                    
                    // set web length to reach player (with some extra swing range)
                    e._swingLen = Math.max(100, distToPlayer * 0.9); // at least 100, usually 90% of distance
                    
                    e._swinging = true;
                    e._swingTimer = 90; // swing duration (1.5 seconds)
                    e._anchorX = ex;
                    e._anchorY = ey - 40; // anchor point above spider
                    e._swingAngle = -Math.PI / 6; // start angle (slightly left)
                    e._swingSpeed = 0.08; // initial swing speed
                    e.vx = 0; // stop crawling
                  }
                  e._attackMode = 'shoot'; // next attack will be shoot
                  e._shootCooldown = 60 + Math.floor(Math.random() * 40);
                }
              }
            } else {
              // swinging attack
              e._swingTimer--;
              
              // pendulum physics
              var gravity = 0.003;
              var damping = 0.995;
              e._swingSpeed += Math.sin(e._swingAngle) * gravity;
              e._swingSpeed *= damping;
              e._swingAngle += e._swingSpeed;
              
              // calculate spider position on swing using dynamic web length
              var swingLen = e._swingLen || 80;
              e.x = e._anchorX + Math.sin(e._swingAngle) * swingLen - e.w / 2;
              e.y = e._anchorY + Math.cos(e._swingAngle) * swingLen;
              
              // check collision with player during swing
              if (p.inv <= 0 && coll({x: e.x, y: e.y, w: e.w, h: e.h},
                {x: p.x + 5, y: p.y + 5, w: p.w - 10, h: p.h - 5})) {
                // hit player - apply knockback only (no damage)
                p.inv = 30; // short invincibility to prevent multiple knockbacks
                
                // apply knockback in direction of swing
                var knockbackX = Math.sin(e._swingAngle) * 15;
                var knockbackY = -8;
                p.vx = knockbackX;
                p.vy = knockbackY;
                p.gnd = 0;
              }
              
              // end swing
              if (e._swingTimer <= 0) {
                e._swinging = false;
                // return to ceiling
                var plIdx = findPlatformIndexAtX(e.x, e.w);
                if (plIdx !== -1) {
                  var platform = g.plat[plIdx];
                  e.y = platform.y - platform.h - 120;
                  e.onCeiling = true;
                }
              }
            }
          } else {
            // normal enemy behavior - patrol and attack
            var dx = p.x - e.x;
            var dist = Math.abs(dx);
            
            // attack logic when close to player
            if (dist < 35 && Math.abs(p.y - e.y) < 50 && !e.attacking && e.attackCooldown <= 0) {
              e.attacking = 1;
              e.attackFrame = 0;
              e.attackCooldown = 60; // cooldown after attack
            }
            
            if (e.attacking) {
              e.attackFrame++;
              // continue moving toward player during attack (slower)
              if (dist > 25) {
                e.vx = Math.sign(dx) * 1.5;
                e.x += e.vx;
              } else {
                e.vx *= 0.7; // slow down when very close
              }
              
              // calculate weapon hitbox based on weapon type and attack frame
              var sd = dx > 0 ? 1 : -1; // face direction based on player position
              var cx = e.x + e.w / 2;
              var cy = e.y;
              var weaponHitbox = null;
              
              if (e.weaponTier === 0) {
                // unarmed punch hitbox
                var progress = e.attackFrame / 15;
                var attackAngle = Math.sin(progress * Math.PI) * Math.PI / 3;
                var armLen = 12;
                var fistX = cx + Math.cos(attackAngle) * armLen * sd;
                var fistY = cy + 22 + Math.sin(attackAngle) * armLen;
                weaponHitbox = {x: fistX - 5, y: fistY - 5, w: 10, h: 10};
              } else if (e.weaponTier === 1) {
                // knife jab hitbox (forward thrust)
                var progress = e.attackFrame / 15;
                var thrust = progress < 0.5 ? progress * 2 : (1 - (progress - 0.5) * 2); // 0 to 1 to 0
                var extendDist = thrust * 10; // matches visual
                var armReach = 8 + extendDist;
                var bladeLen = 15; // increased blade length
                var totalReach = armReach + bladeLen;
                var knifeX = cx + totalReach * sd;
                var knifeY = cy + 22;
                weaponHitbox = {x: knifeX - 8, y: knifeY - 8, w: 16, h: 16};
              } else if (e.weaponTier === 2) {
                // sword swing hitbox
                var attackAngle = (e.attackFrame / 15) * Math.PI - Math.PI / 4;
                var armLen = 12;
                var armX = cx + Math.cos(attackAngle) * armLen * sd;
                var armY = cy + 25 + Math.sin(attackAngle) * armLen;
                var swordLen = 28;
                var swordX = armX + Math.cos(attackAngle) * swordLen * sd;
                var swordY = armY + Math.sin(attackAngle) * swordLen;
                // sword hitbox as a rectangle along the blade
                var minX = Math.min(armX, swordX) - 5;
                var maxX = Math.max(armX, swordX) + 5;
                var minY = Math.min(armY, swordY) - 5;
                var maxY = Math.max(armY, swordY) + 5;
                weaponHitbox = {x: minX, y: minY, w: maxX - minX, h: maxY - minY};
              }
              
              // check weapon hitbox collision with player
              if (weaponHitbox && p.inv <= 0 && e.attackFrame >= 5 && e.attackFrame <= 12) {
                if (coll(weaponHitbox, {x: p.x + 5, y: p.y + 5, w: p.w - 10, h: p.h - 5})) {
                  var damage = e.weaponTier === 2 ? 2 : 1;
                  p.hp -= damage;
                  p.inv = 90;
                  upHp();
                  damageSound();
                  if (p.hp <= 0) endGame();
                }
              }
              
              if (e.attackFrame >= 15) {
                e.attacking = 0;
                e.attackFrame = 0;
              }
            } else {
              // patrol and chase behavior
              if (dist < 150 && Math.abs(p.y - e.y) < 80) {
                // chase player when in range
                e.vx = Math.sign(dx) * 2;
                e.x += e.vx;
              } else {
                // normal patrol
                e.x += e.vx;
                if (e.x <= e.pl || e.x + e.w >= e.pr) e.vx *= -1;
              }
            }
            
            if (e.attackCooldown > 0) e.attackCooldown--;
            
            // ensure y aligned to platform if possible
            var plIdx = findPlatformIndexAtX(e.x, e.w);
            if (plIdx !== -1) {
              e.y = g.plat[plIdx].y - e.h;
              e.gnd = 1;
            }
          }
          // swing hit on enemy
          if (p.swing) {
            var sh = getSwHit(p);
            if (coll(sh, e)) {
              e.dead = 1;
              g.sc += (e.type === 'hunter' ? 500 : 200);
              upSc();
              coinSound();
              dropPowerup(e.x + e.w / 2, e.y);
              if (e.type === 'hunter') {
                g.hunters = g.hunters.filter(function(h) {
                  return h !== e
                });
                if (g.hunters.length === 0) g.spawnMul = 1;
              }
            }
          }
          // hunter escape: if it passes player, increase spawn rate
          if (e.type === 'hunter' && !e.escaped && e.x > g.p.x) {
            e.escaped = 1;
            g.spawnMul = 1.5;
            g.hunters.push(e);
          }
          // collision damage (exclude spiders - they only damage via web projectile)
          if (!e.dead && e.type !== 'spider' && p.inv <= 0 && coll({
              x: p.x + 5,
              y: p.y + 5,
              w: p.w - 10,
              h: p.h - 5
            }, {
              x: e.x,
              y: e.y,
              w: e.w,
              h: e.h
            })) {
            p.hp--;
            p.inv = 90;
            upHp();
            damageSound();
            if (p.hp <= 0) endGame()
          }
        }
        // projectiles update & collisions
        for (var i = g.projectiles.length - 1; i >= 0; i--) {
          var pr = g.projectiles[i];
          pr.x += pr.vx;
          pr.y += (pr.vy || 0);
          pr.life--;
          
          // player arrow hits enemies
          if (pr.type === 'arrow') {
            for (var j = 0; j < g.en.length; j++) {
              var e = g.en[j];
              if (e.dead) continue;
              if (coll({
                  x: pr.x,
                  y: pr.y,
                  w: pr.w,
                  h: pr.h
                }, e)) {
                // Damage scales: fully charged shot deals 5 damage, otherwise 1
                var base = (pr.power && pr.power >= 1) ? 5 : 1;
                var dmgMul = 1 + ((g.upgrades && g.upgrades.damage) ? (0.5 * g.upgrades.damage) : 0);
                var dmg = Math.max(1, Math.round(base * dmgMul));
                e.hp = (e.hp || 1) - dmg;
                pr.life = 0;
                if (e.hp <= 0) {
                  e.dead = 1;
                  g.sc += 150;
                  upSc();
                  coinSound();
                  dropPowerup(e.x + e.w / 2, e.y, 0.25); // 25% drop rate for arrow kills
                }
              }
            }
          }
          // enemy arrow hits player
          else if (pr.type === 'enemy_arrow') {
            if (!p.dead && coll({
                x: pr.x,
                y: pr.y,
                w: pr.w,
                h: pr.h
              }, {
                x: p.x + 5,
                y: p.y + 5,
                w: p.w - 10,
                h: p.h - 5
              })) {
              p.hp--;
              p.inv = 90;
              upHp();
              damageSound();
              pr.life = 0;
              if (p.hp <= 0) endGame()
            }
          }
          // spider web hits player
          else if (pr.type === 'web') {
            if (!p.dead && p.frozen <= 0 && coll({x: pr.x, y: pr.y, w: pr.w, h: pr.h}, 
              {x: p.x + 5, y: p.y + 5, w: p.w - 10, h: p.h - 5})) {
              // freeze player for ~2 seconds (120 frames at 60fps)
              p.frozen = 120;
              // capture current velocity to maintain arc if in air
              p.frozenVx = p.vx;
              p.frozenVy = p.vy;
              pr.life = 0;
            }
          }
          
          if (pr.life <= 0) g.projectiles.splice(i, 1)
        }
        // powerup physics and collision
        for (var i = g.powerups.length - 1; i >= 0; i--) {
          var pu = g.powerups[i];
          pu.life--;
          pu.vy += 0.4; // gravity
          pu.y += pu.vy;
          pu.x += pu.vx;
          pu.vx *= 0.98; // friction
          
          // platform collision - bounce or land
          for (var j = 0; j < g.plat.length; j++) {
            var pl = g.plat[j];
            if (pu.vy >= 0 && pu.x + pu.w > pl.x && pu.x < pl.x + pl.w && pu.y + pu.h >= pl.y && pu.y + pu.h <= pl.y + pl.h + 15) {
              pu.y = pl.y - pu.h;
              pu.vy *= -0.3; // bounce
              if (Math.abs(pu.vy) < 0.5) pu.vy = 0;
            }
          }
          
          // player collision - apply powerup
          if (coll({x: p.x + 5, y: p.y + 5, w: p.w - 10, h: p.h - 5}, pu)) {
            if (pu.type === 'health') {
              var maxHp = classes[selClass].hp + (g.upgrades ? (g.upgrades.health || 0) : 0);
              p.hp = Math.min(p.hp + 2, maxHp);
              upHp();
            } else if (pu.type === 'speed') {
              p._speedBoost = 120; // 2 seconds of speed
            } else if (pu.type === 'shield') {
              p.inv = 180; // 3 seconds of invincibility
            }
            g.powerups.splice(i, 1);
          } else if (pu.life <= 0) {
            g.powerups.splice(i, 1);
          }
        }
        for (var i = 0; i < g.coinItems.length; i++) {
          var co = g.coinItems[i];
          if (!co.c) {
            var d = Math.sqrt(Math.pow(co.x - (p.x + 15), 2) + Math.pow(co.y - (p.y + 25), 2));
            if (d < co.r + 20) {
              co.c = 1;
              g.sc += 100;
              upSc();
              coinSound()
            }
          }
        }
        for (var i = 0; i < g.obs.length; i++) {
          var o = g.obs[i];
          if (p.inv <= 0 && coll({
              x: p.x + 5,
              y: p.y + 5,
              w: p.w - 10,
              h: p.h - 5
            }, o)) {
            p.hp--;
            p.inv = 90;
            upHp();
            damageSound();
            if (p.hp <= 0) endGame()
          }
        }
        if (p.y > H + 50) endGame();
        var nd = Math.floor(p.x / 50);
        if (nd > g.dist) {
          g.sc += nd - g.dist;
          g.dist = nd;
          upSc();
          updateBestDiff()
        }
        g.plat = g.plat.filter(function(p) {
          return p.x + p.w > g.cam - 200
        });
        g.coinItems = g.coinItems.filter(function(c) {
          return c.x > g.cam - 200
        });
        g.obs = g.obs.filter(function(o) {
          return o.x > g.cam - 200
        });
        g.en = g.en.filter(function(e) {
          return e.x > g.cam - 200
        });
        // Ensure we have at least one platform, regenerate if all were removed
        if (g.plat.length === 0) {
          g.plat.push({x: g.cam + 100, y: 350, w: 200, h: 15});
        }
        var lp = g.plat[g.plat.length - 1];
        if (lp && lp.x + lp.w < g.cam + W + 400) {
          var np = genPlat(lp.x + lp.w, lp);
          g.plat.push(np);
          g.pgen++;
          var co = genCoin(np);
          if (co) g.coinItems.push(co);
          var ob = genObs(np, g.pgen);
          if (ob) g.obs.push(ob);
          var e = genEn(np, g.pgen);
          if (e && Math.random() < g.spawnMul) {
            g.en.push(e);
            if (e.type === 'hunter') g.hunters.push(e)
          } else if (e) g.en.push(e)
        }
        for (var i = 0; i < g.plat.length; i++) drawPlat(g.plat[i], g.cam);
        for (var i = 0; i < g.coinItems.length; i++) drawCoin(g.coinItems[i], t, g.cam);
        for (var i = 0; i < g.obs.length; i++) drawObs(g.obs[i], g.cam);
        // draw spider web strands for swinging spiders (before enemies so strands appear behind)
        for (var i = 0; i < g.en.length; i++) {
          var e = g.en[i];
          if (e.type === 'spider' && e._swinging && !e.dead) {
            var sx = e._anchorX - g.cam;
            var sy = e._anchorY;
            var ex = e.x + e.w / 2 - g.cam;
            var ey = e.y + 10;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(209, 213, 219, 0.8)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
            ctx.shadowBlur = 4;
            
            // draw web strand
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
            
            // draw anchor point
            ctx.fillStyle = '#9ca3af';
            ctx.beginPath();
            ctx.arc(sx, sy, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
          }
        }
        for (var i = 0; i < g.en.length; i++) drawEn(g.en[i], g.cam);
        // draw powerups
        for (var i = 0; i < g.powerups.length; i++) {
          var pu = g.powerups[i];
          var x = pu.x - g.cam;
          var y = pu.y;
          ctx.save();
          // spinning animation
          var angle = (t / 10) % (Math.PI * 2);
          ctx.translate(x + pu.w / 2, y + pu.h / 2);
          ctx.rotate(angle);
          
          if (pu.type === 'health') {
            // red health cross
            ctx.fillStyle = '#ef4444';
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 4;
            ctx.fillRect(-2, -6, 4, 12);
            ctx.fillRect(-6, -2, 12, 4);
          } else if (pu.type === 'speed') {
            // yellow lightning bolt
            ctx.fillStyle = '#eab308';
            ctx.shadowColor = '#ca8a04';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.moveTo(0, -7);
            ctx.lineTo(3, -1);
            ctx.lineTo(1, -1);
            ctx.lineTo(4, 7);
            ctx.lineTo(-1, 2);
            ctx.lineTo(0, 2);
            ctx.closePath();
            ctx.fill();
          } else if (pu.type === 'shield') {
            // cyan shield star
            ctx.fillStyle = '#06b6d4';
            ctx.shadowColor = '#0891b2';
            ctx.shadowBlur = 4;
            for (var s = 0; s < 5; s++) {
              var angle = (s * Math.PI * 2 / 5) - Math.PI / 2;
              var px = Math.cos(angle) * 7;
              var py = Math.sin(angle) * 7;
              if (s === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }
        for (var i = 0; i < g.projectiles.length; i++) {
          var pr = g.projectiles[i];
          ctx.save();
          if (pr.type === 'arrow' || pr.type === 'enemy_arrow') {
            // draw rotated arrow projectile
            var px = pr.x - g.cam,
              py = pr.y;
            var ang = pr.rot || Math.atan2(pr.vy || 0, pr.vx || 0);
            ctx.translate(px + pr.w / 2, py + pr.h / 2);
            ctx.rotate(ang);
            // shaft
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#ef4444' : '#f3f4f6';
            ctx.fillRect(-2, -1, 20, 2);
            // fletching
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#dc2626' : '#f59e0b';
            ctx.beginPath();
            ctx.moveTo(-2, -1);
            ctx.lineTo(-6, -5);
            ctx.lineTo(-6, 5);
            ctx.closePath();
            ctx.fill();
            // head
            ctx.fillStyle = pr.type === 'enemy_arrow' ? '#b91c1c' : '#374151';
            ctx.beginPath();
            ctx.moveTo(18, 0);
            ctx.lineTo(14, -4);
            ctx.lineTo(14, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          } else if (pr.type === 'web') {
            // draw web projectile
            var px = pr.x - g.cam,
              py = pr.y;
            ctx.fillStyle = '#d1d5db';
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            // web blob
            ctx.beginPath();
            ctx.arc(px + 6, py + 6, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // web strands
            ctx.strokeStyle = 'rgba(156,163,175,0.5)';
            ctx.lineWidth = 1;
            for (var ws = 0; ws < 4; ws++) {
              var angle = (ws * Math.PI / 2) + (pr.life * 0.1);
              ctx.beginPath();
              ctx.moveTo(px + 6, py + 6);
              ctx.lineTo(px + 6 + Math.cos(angle) * 10, py + 6 + Math.sin(angle) * 10);
              ctx.stroke();
            }
            ctx.restore();
          } else {
            // default projectile - simplified for performance
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(pr.x - g.cam, pr.y, pr.w, pr.h);
            ctx.restore();
          }
        }
        // draw target lock indicator for archer
        if (cls.ranged && g.targetLock && !g.targetLock.dead) {
          var tx = g.targetLock.x - g.cam,
            ty = g.targetLock.y + 12;
          ctx.save();
          ctx.strokeStyle = 'rgba(52,211,153,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(tx, ty, 20, 0, Math.PI * 2);
          ctx.stroke();
          var rot = (t * 0.01) % (Math.PI * 2);
          ctx.strokeStyle = 'rgba(52,211,153,0.8)';
          ctx.lineWidth = 1.5;
          for (var j = 0; j < 4; j++) {
            var angle = rot + (j * Math.PI / 2);
            var x1 = tx + Math.cos(angle) * 25;
            var y1 = ty + Math.sin(angle) * 25;
            ctx.beginPath();
            ctx.moveTo(tx + Math.cos(angle) * 22, ty + Math.sin(angle) * 22);
            ctx.lineTo(x1, y1);
            ctx.stroke();
          }
          ctx.restore();
        }
        // debug render for hunters (optional)
        if (g.showHunterDebug && typeof renderHunterDebug === 'function') renderHunterDebug(ctx, g, g.cam);
        drawStick(p, g.cam);
        } catch (err) {
          logError('Game loop error', err);
          // Continue loop even on error
          anim = requestAnimationFrame(loop);
        }
      }

      function startGame() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        document.getElementById('over').classList.add('hidden');
        init();
        anim = requestAnimationFrame(loop)
      }

      function restart() {
        document.getElementById('over').classList.add('hidden');
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('classSelect').classList.add('hidden');
        document.getElementById('settings').classList.add('hidden');
        if (anim) cancelAnimationFrame(anim);
        init();
        anim = requestAnimationFrame(loop)
      }

      function clearHighScore() {
        if (confirm('Clear high score? This cannot be undone.')) {
          g.hi = 0;
          setCookie('highScore', 0);
          document.getElementById('highScoreDisplay').value = '0';
          upSc()
        }
      }

      function key(k, v) {
        g.k[k] = v
      }
      
      // Fullscreen functionality with cross-platform support
      function toggleFullscreen() {
        var elem = document.documentElement;
        var btn = document.getElementById('fullscreenBtn');
        
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
          // Enter fullscreen
          if (elem.requestFullscreen) {
            elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) { // Safari
            elem.webkitRequestFullscreen();
          } else if (elem.mozRequestFullScreen) { // Firefox
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) { // IE/Edge
            elem.msRequestFullscreen();
          }
          
          // Lock orientation to landscape on mobile if supported
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(function() {});
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
          
          // Unlock orientation
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
        }
      }
      
      // Update button icon when fullscreen state changes
      function updateFullscreenButton() {
        var btn = document.getElementById('fullscreenBtn');
        if (btn) {
          if (document.fullscreenElement || 
              document.webkitFullscreenElement || 
              document.mozFullScreenElement || 
              document.msFullscreenElement) {
            btn.textContent = '‚õ∂'; // Exit fullscreen icon
          } else {
            btn.textContent = '‚õ∂'; // Enter fullscreen icon
          }
        }
      }
      
      // Keyboard detection for mobile controls
      var hasPhysicalKeyboard = false;
      var keyboardCheckTimeout = null;
      
      function checkForPhysicalKeyboard() {
        // Check if device has a physical keyboard by detecting keyboard events
        var controls = document.querySelector('.controls');
        
        // On mobile/tablet without keyboard, controls show via CSS media query
        // If we detect keyboard input, hide them
        if (hasPhysicalKeyboard && controls) {
          controls.style.display = 'none';
        } else if (controls && window.innerWidth <= 768) {
          // Only show if mobile size and no keyboard detected
          if (!hasPhysicalKeyboard) {
            controls.style.display = 'flex';
          }
        }
      }
      
      // Detect physical keyboard by monitoring for actual key presses
      function onKeyboardDetected() {
        if (!hasPhysicalKeyboard) {
          hasPhysicalKeyboard = true;
          checkForPhysicalKeyboard();
        }
        
        // Reset the flag after 30 seconds of no keyboard activity
        clearTimeout(keyboardCheckTimeout);
        keyboardCheckTimeout = setTimeout(function() {
          hasPhysicalKeyboard = false;
          checkForPhysicalKeyboard();
        }, 30000);
      }
      
      // Listen for keyboard events to detect physical keyboard
      window.addEventListener('keydown', function(e) {
        // Only consider actual game control keys to avoid false positives
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 
             'a', 'A', 'd', 'D', 'w', 'W', ' ', 'Shift', 'k', 'K'].includes(e.key)) {
          onKeyboardDetected();
        }
      });
      
      // Check on window resize
      window.addEventListener('resize', checkForPhysicalKeyboard);
      
      // Initial check
      setTimeout(checkForPhysicalKeyboard, 100);
      
      // Listen for fullscreen changes
      document.addEventListener('fullscreenchange', updateFullscreenButton);
      document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
      document.addEventListener('mozfullscreenchange', updateFullscreenButton);
      document.addEventListener('MSFullscreenChange', updateFullscreenButton);
      
      window.addEventListener('keydown', function(e) {
        if (e.key == 'ArrowLeft' || e.key == 'a' || e.key == 'A') g.k.left = 1;
        if (e.key == 'ArrowRight' || e.key == 'd' || e.key == 'D') g.k.right = 1;
        if (e.key == 'ArrowUp' || e.key == 'w' || e.key == 'W' || e.key == ' ') {
          e.preventDefault();
          g.k.up = 1
        }
        if (e.key == 'Shift') {
          e.preventDefault();
          g.k.swing = 1
        }
        if (e.key == 'k' || e.key == 'K') {
          if (!e.repeat) g.k.attack = 1
        }
        if ('123'.includes(e.key)) {
          selectClass(parseInt(e.key) - 1)
        }
        // F key or F11 for fullscreen toggle
        if (e.key == 'f' || e.key == 'F') {
          e.preventDefault();
          toggleFullscreen();
        }
      });
      window.addEventListener('keyup', function(e) {
        if (e.key == 'ArrowLeft' || e.key == 'a' || e.key == 'A') g.k.left = 0;
        if (e.key == 'ArrowRight' || e.key == 'd' || e.key == 'D') g.k.right = 0;
        if (e.key == 'ArrowUp' || e.key == 'w' || e.key == 'W' || e.key == ' ') g.k.up = 0;
        if (e.key == 'Shift') g.k.swing = 0;
        if (e.key == 'k' || e.key == 'K') g.k.attack = 0;
      });
      // reset input state on window blur to prevent stuck keys
      window.addEventListener('blur', function() {
        g.k = {
          left: 0,
          right: 0,
          up: 0,
          swing: 0,
          attack: 0
        };
      });
      // Initialize on load
      updateClassUI();
      drawClassPreview();
      drawMainMenuCharPreview();
      document.getElementById('highScoreDisplay').value = g.hi;
      document.getElementById('highScoreDisplay2').textContent = g.hi;
      document.getElementById('volumeSlider').value = soundVolume;
    </script>
  </body>
</html>